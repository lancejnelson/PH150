[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beginning Physics Lab",
    "section": "",
    "text": "Python and Jupyter Notebooks\nJupyter Notebook"
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Beginning Physics Lab",
    "section": "Python",
    "text": "Python\nPython is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, with a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a compiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or university you are affiliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect, modify, and use. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites."
  },
  {
    "objectID": "index.html#installing-software",
    "href": "index.html#installing-software",
    "title": "Beginning Physics Lab",
    "section": "Installing Software",
    "text": "Installing Software\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of softwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest."
  },
  {
    "objectID": "index.html#jupyter-notebooks",
    "href": "index.html#jupyter-notebooks",
    "title": "Beginning Physics Lab",
    "section": "Jupyter Notebooks",
    "text": "Jupyter Notebooks\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nNotebook Structure\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. An example of a code cell is given below:\n\naccel = 9.8\ndt = 0.5\nvi = 10\nvf = vi + a * dt\nprint(vf)\n\nMarkdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells support markdown, html, and \\(\\mathrm{\\LaTeX}\\) (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your cursor is in the desired cell.\n\n\nNavigating Jupyter Notebooks\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode."
  },
  {
    "objectID": "index.html#tips-for-studying-jupyter-notebooks",
    "href": "index.html#tips-for-studying-jupyter-notebooks",
    "title": "Beginning Physics Lab",
    "section": "Tips for studying Jupyter notebooks",
    "text": "Tips for studying Jupyter notebooks\n\nPrint Statements\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\nComments\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconsin at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on that line the follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "",
    "text": "Introduction to Error Analysis\nJupyter Notebook\nName:"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#skills",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#skills",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Skills",
    "text": "Skills\nIn this lab you will gain the following skills..\n\nUse Python to perform simple calculations.\nUse formatted print statements in Python to display results.\nUse Python to make a simple plot, including error bars.\nTake measurements and assign uncertainties.\n\nPropagate uncertainties for simple calculations.\nUnderstand the difference between precision and accuracy.\nCalculate percent error and explain its experimental significance.\nCalculate fractional uncertainty and explain its experimental significance.\nCorrectly display results with their associated uncertainty.\nUnderstand the role of significant figures for communicating uncertainties."
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#background-information",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#background-information",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Background Information",
    "text": "Background Information\n\nAn Historical Example\nIn 1826, J.K.F Sturm and J.D. Collandon designed an experiment to calculate the speed of sound in seawater. The two men sat in boats separated by 16 kilometers. A bell was suspended in the lake from Sturm’s boat which could be struck by a hammer that was operated by Sturm at the surface. At the exact moment that the hammer struck the bell it also ignited some gun powder which produced an above-water flash. An underwater ear-trumpet was suspended from Collandon’s boat to receive the sound wave emitted by the bell. By measuring the time difference between the flash and the bell’s tone, the scientists were able to calculate the speed of sound to be \\(1435\\) m/s, which was remarkably close to the modern value of \\(1438\\) m/s.\n\n\n\nIf this experiment had been repeated many times the results would have been slightly different every time. This is because experiments always involve measurements, and measurements always have some variability (or uncertainty) associated with them. For example, to measure the difference in time between the bell and the flash involves the use of a watch and a human to operate that watch. A simple analog watch may be able to measure to the nearest second or maybe half second but no smaller. Typical reaction times for humans varies between \\(0.17\\) s (audio stimulus) and \\(0.25\\) s (visual stimulus). Another important measurement that would surely have some variation is the distance between the boats (reported to be \\(16\\) km). Variations in the water temperature and pressure could also change the true value of the speed of sound and therefore make the time measurements differ. Although there is only one true value for the speed of sound in fresh water (at a given temperature and pressure) multiple measurements of this quantity will never be identical. This is represented in the figure below, which is an example of what multiple measurements of the speed of sound may have looked like for Sturm and Collandon. Each vertical bar gives the number of times that the measured speed of sound occurred at that value.\n\n\n\n\n\nAs with the speed of sound experiment, every scientific experiment performed will have measurements, and those measurements will always have variability (or uncertainty) associated with them. In this lab (and several others) we will get practice taking measurements, assigning uncertainty to those measurements, and correctly reporting the uncertainty of calculations.\n\n\nUncertainties in Measurements\nMeasuring involves the use of a measuring device of some sort, such as a ruler, balance, microphone, voltmeter, or any other sensor. When measuring a physical property of an object, we assume that there is a unique “correct” value for this measurement. The problem is that we can never measure this “correct” value because no instrument is perfectly precise and no experiment is free from variability. We have to make do with the goal of getting as close as we can to the “correct” value and doing our best to accurately state the uncertainty.\nThere are several factors that affect your ability to perform experiments with perfect precision:\n\nLimited accuracy of measuring devices.\nCalibration of measuring devices\nChanges in physical conditions of experiment\nSimplification of experiment. (e.g. Neglecting small but not negligible forces)\n\n\n\nAnalog Measurements\nAll measuring devices fall into one of two categories: analog and digital. Analog devices usually have a set of tick marks and a scale printed on them. Meter sticks, spring scales, calipers, multimeters (comes in both analog and digital) are all examples of analog devices. Digital devices display the measurement on an electronic display. Both types of devices have uncertainty associated with them.\nConsider the example shown in figure below where we use a meter stick to measure the length of a rod. If you look close, you’ll notice that the end of the rod falls between the tick marks on the meter stick. Such will almost always be the case. If you were to look really close, you’d notice that the tick marks themselves have finite width. Therefore, even if the end of the rod landed on a tick mark, you still wouldn’t know which part of the tick mark it was. Every instrument is limited to some degree in this way.\n\n\n\nSo we can never really know the true length of the rod, or the true value of any other measurement. The best we can do is to provide a range of values that we are sure will include the true value. In this example, a range of \\((97.6-97.7)\\) would certainly include the correct value, but this range is probably too broad. On the other hand, choosing a range of \\((97.64-97.66)\\) might be too small so as to not actually include the true value. The correct length is probably \\(97.65\\) with a certainty range of \\((97.62-97.68)\\). Another way to say that is to report \\[l = 97.65 \\pm .03 \\mathrm{~~cm}\\]\nIn this case, \\(97.65\\) cm is the measured value and \\(.03\\) cm is the uncertainty associated with it. Uncertainties are always rounded to one significant figure and the measured value is rounded to the same decimal place as the uncertainty. It is critical in experimental science that every measurement is reported with an uncertainty value. The number alone is useless without knowing the possible range of values that it falls within.\n\n\nDigital Measurements\nMeasurements made from digital devices will carry uncertainty too. This uncertainty arises because the device must round the measurement so that it fits on the digital readout. Uncertainty arises since you can never know what the next digit would have been. For example, suppose that you measure the mass of an object on a digital scale and it reads \\(10.55\\) kg. The actual value of the measurement could have been as low as \\(10.545\\) kg or as high as \\(10.555\\) kg. Anything in that range would have rounded to \\(10.55\\) kg. Hence, the uncertainty on this measurement is \\(\\pm 0.005\\) kg. This measurement would be reported as \\(10.55 \\pm .005\\) kg. Unless otherwise stated on the device, the uncertainty of a digital measurement is half of the value of the last decimal place shown.\n\n\nOther Sources of Uncertainty\nSometimes the biggest source of uncertainty in a measurement is not due to the instrument itself but the experimental setup. For example, if a digital timer is used to time the drop of a tennis ball, the reaction time of the person operating the timer will be bigger than the explicit uncertainty in the timer itself. (For reference, the typical reaction time for auditory stimuli is \\(0.14 - 0.16\\) s and \\(0.18 - 0.2\\) for visual stimuli.) The placement of a meter stick may vary from measurement to measurement due to human variability and this would introduce some variability in the subsequent measurements. Fluctuations in the environmental conditions (temperature, pressure, etc) can cause variability in measurements. All of these factors must be considered when assigning uncertainties to measured values.\n\n\nPrecision vs. Accuracy\nIn science, we use two terms that often can cause confusion, since in everyday language they tend to be synonymous. They are precision and accuracy. Precision is a measure of the uncertainty in a measurement. In other words, high precision means low uncertainty. Accuracy, on the other hand, means a measurement agrees well with an accepted standard. The figure below illustrates the concept of precision vs. accuracy when throwing darts at a dartboard.\nWhen all of your measurements are offset from the true value (blue dots in the figure) we call it a systematic error. An example of a systematic error would be using a measuring tape on a hot day. Because the length of the measuring tape has thermally expanded, any measurements taken will be smaller than they should be. There is no way to detect a systematic error by simply gathering data; you must uncover it based on the experimental circumstances.\n\n\n\n\n\nFractional Uncertainty\nOne way to express precision is as a fractional uncertainty:\n\\[\\begin{align}\n\\mathrm{fractional ~ uncertainty} &=\n\\frac{\\mathrm{uncertainty}}{\\mathrm{measured ~value}}\n\\end{align}\\]\nFractional uncertainty are dimensionless quantities that describe how large the uncertainty is compared to the measurement. They serve as a rough indication of the quality of the measurement. Fractional uncertainties of \\(10\\%\\) or so are usually characteristic of rough measurements. (Think about measuring the length of a 10 cm object and assigning an uncertainty of 1 cm.. It’s not super great, but not terrible either). Fractional uncertainties of \\(1\\%\\) of \\(2\\%\\) are characteristic of reasonably careful measurements and are about the best we can hope for in any lab that we do. Fractional uncertainties less that \\(1\\%\\) will be difficult to achieve in an introductory lab setting.\n\n\nPercent Error\nAccuracy is often expressed as a percentage error. There are slightly different ways of defining and using percentage error, depending on which scientific field you are in. In this course we will define percentage error as\n\\[\\mathrm{\\% ~error}=\\frac{(\\mathrm{measured~ value}) - (\\mathrm{theoretical~value})}{(\\mathrm{theoretical ~ value})}\\]\nThe sign of the percentage error then has meaning: a negative percent error means the measured value is less than the theoretical or accepted value, and a positive percent error means the measured value is larger then the theoretical value. High accuracy is reflected by a low percentage error.\n\nJudging the success of an experiment\nA comparison of the fractional uncertainty and percent error determines whether the experimental result is consistent with the hypothesis (or known quantity). If the percentage error is smaller than the fractional uncertainty, the experiment is judged to be a success since the true value falls within the uncertainty of the result. For example, suppose an experiment to determine the acceleration due to gravity results in \\(9.86 \\pm .03\\) m/s\\(^2\\). The fractional uncertainty would be\n\\[\\mathrm{fractional~ uncertainty} = \\frac{0.03}{9.86} = 0.0030 = 0.3 \\%\\] while the percentage error compared to the accepted value of \\(9.80\\) m/s\\(^2\\) would be \\[\\mathrm{\\% ~error} = \\frac{9.86 ~\\mathrm{m}/\\mathrm{s}^{2}-9.80~\n  \\mathrm{m}/\\mathrm{s}^{2}}{9.80~ \\mathrm{m}/\\mathrm{s}^{2}} =\n0.0061 = 0.61\\%\\] Since the percent error is larger than the fractional uncertainty we would claim that our experiment did not successfully confirm the widely accepted value of \\(g\\). In this case, the scientists should look for possible systematic errors or underestimated uncertainties in the experiment before proceeding.\nConversely, suppose the measurement of the acceleration due to gravity resulted in the experimental value of \\(10 \\pm 2\\) m/s\\(^2\\). The fractional uncertainty is \\(20\\%\\) and the percent error is \\(2.0\\%\\). We could conclude that the experiment successfully confirmed the value of \\(g\\). Your goal in any measurement should be to obtain both accuracy and precision.\n\n\n\nDisplaying Results with Uncertainty\nOften it will be valuable to produce a visual representation of your value with its uncertainty. As an example, imagine that you and a friend each performed an experiment to measure the acceleration due to gravity and you’d like to compare your results visually. If the results of the two experiments were \\[g = 9.6 \\pm 0.3 ~\\text{m/s}^2\\] \\[g = 10.1 \\pm 0.2 ~\\text{m/s}^2\\] you could use Python to plot these two measurements with their uncertainties like this\n\nfrom matplotlib.pyplot import errorbar,show,xticks,plot\n\nx = [2,3]\ny = [9.6,10.1]\ndy = [0.3,0.2]\nerrorbar(x,y,yerr = dy,capsize = 10,marker = \"o\",linewidth = 2,capthick = 2,ls = 'none',xticks = None)\nplot([0,4],[9.8,9.8],ls = 'dashed')\nxticks([],[])\nshow()\n\n\n\n\nIn this case, the measurement whose uncertainty window contains the accepted value could claim a successful experiment, while the other measurement could not.\n\n\nSignificant Figures\nAt this point, you may be wondering about all of those numbers in your physics textbook that are given to you without any \\(\\pm\\) value attached to them. In the absence of an explicitly-stated uncertainty, it is generally assumed that the uncertainty is \\(\\pm 5\\) on the digit that is one beyond the least significant digit. For example, if your homework problem states that a car was traveling with speed \\(25\\) m/s, it is implied that the uncertainty on that length is \\(\\pm 0.5\\) m/s. After all, if the true value were anywhere in the range \\((24.5 - 25.5)\\), we would have rounded the final answer to \\(25\\) m/s.\nThe numbers used to communicate the precision of a measurement are called significant figures. The rules for tracking and reporting of significant figures that you learn in physics and chemistry class are a quick and dirty way to keep track of these uncertainties as they are used to perform calculations. They ensure that the implied uncertainty in a calculated value is not wildly incongruent with the uncertainty in the data provided.\nHowever, using significant figures to communicate uncertainty does have it’s drawbacks. For example, let’s say that you measure the length of a rod and determine that lies in the range \\((10.5 - 10.6)\\) cm. In other words, you would report the length of the rod to be \\(10.55 \\pm .05\\) cm. You can’t communicate this uncertainty using significant figures. If you report the length to be \\(10.5\\) cm, you’re implying that the actual value is somewhere in the range of \\((10.45 - 10.55)\\) which isn’t the correct window. If you report the length to be \\(10.55\\) cm, you’re implying that the value is somewhere in the range \\((10.545 - 10.555)\\) cm, which is too narrow. We use significant figures because it’s easy and it communicates an uncertainty that is close, but not perfect.\nThe number of significant figures that a number has is an indication of its fractional uncertainty. For example, if you report your mass to be \\(m = 75\\) kg, you are implying an uncertainty of \\(\\pm .5\\) and thus a fractional uncertainty of \\({.5 \\over 75} = 0.7\\%\\). But if you report your mass to be \\(m = 75.1\\) kg you are implying an uncertainty of \\(\\pm .05\\) and thus a fractional uncertainty of \\({.05 \\over 75} = 0.07\\%\\). Roughly speaking for each significant figure that is gained the fractional uncertainty decreases by an order of magnitude. Below you will find a table with approximate correspondence between fractional uncertainties and significant figures.\n\n\n\nNumber of significant figures\nFractional Uncertainty\n\n\n\n\n1\n\\(10\\%\\) — \\(50\\%\\)\n\n\n2\n\\(1\\%\\) — \\(10\\%\\)\n\n\n3\n\\(0.1\\%\\) — \\(1\\%\\)\n\n\n\n\n\nCombining Uncertainties\nOften we will need to use measured values, with their associated uncertainties, to calculate another value. For example, let’s say we measure the dimensions of a square plate to be: \\(l = 10.2 \\pm 0.3\\) cm and \\(w = 18.3 \\pm 5\\) cm. Next, we calculate the area to be:\n\\[A = l\\times w = 10.2 \\times 18.3 = 186.66 ~\\mathrm{cm}^2\\].\nWhat is the uncertainty in the area? In other words, how does the uncertainty in the measurements propagate through the calculation to the uncertainty in the area?\nOne way to answer this question is to simply ask, ““What is the maximum and minimum values of the area?”“. As you probably could have guessed, the maximum possible value for the area is\n\\[A_\\mathrm{max} = 10.5 \\times 18.8 = 197.4 ~\\mathrm{cm}^2\\]\nand the minimum possible value is \\[A_\\mathrm{min} = 9.9 \\times 17.8 = 176.22 ~\\mathrm{cm}^2\\] .\nTherefore, the actual value of the area must be somewhere between \\(176.22\\) cm\\(^2\\) and \\(197.4\\) cm\\(^2\\) (a range of \\(20\\) cm\\(^2\\)) and we could report the area as: \\[A = 187 \\pm 10 ~\\mathrm{cm}\\]\nThe high-low method is great at illustrating how measurement errors can affect results, but should never be used in a professional setting.\n\nThe algebraic method (no Calculus yet!)\nUsing algebra, we can develop rules for combining uncertainty when multiplying, dividing, adding, subtracting, or raising variables to whole number powers. These rules will cover many simple situations, but eventually we will need to know how to estimate uncertainty for any function as will be covered in a future lab. For now our goal is to have a method that you can use without calculus.\n\n\n\n\n\n\n\n\nFunction\nCalculation\nUncertainty Formula    \n\n\n\n\nAddition\n\\(z = x + y\\)\n\\(\\delta z^2 = \\delta x^2 + \\delta y^2\\)\n\n\nSubtraction\n\\(z = x - y\\)\n\\(\\delta z^2 = \\delta x^2 + \\delta y^2\\)\n\n\nMultiplication\n\\(z = xy\\)\n\\(({\\delta z\\over z})^2 = ({\\delta x \\over x})^2 + ({\\delta y \\over y})^2\\)\n\n\nDivision\n\\(z = {x\\over y}\\)\n\\(({\\delta z\\over z})^2 = ({\\delta x \\over x})^2 + ({\\delta y \\over y})^2\\)\n\n\nMultiply by Constant\n\\(z = Ax\\)\n\\(\\delta z = A\\delta x\\)\n\n\nPowers\n\\(z = x^n\\)\n\\({\\delta z\\over |z|} = n{\\delta x \\over |x|}\\)\n\n\n\nUsing these rules on the example from above, we would find the following uncertainty in the area of the plate. \\[\\begin{align*}\n{\\delta A\\over A} &= \\sqrt{{\\delta l\\over l}^2 + {\\delta w \\over w}^2}\\\\\n&= \\delta A = A \\sqrt{({\\delta l\\over l})^2 + ({\\delta w \\over w})^2}\\\\\n&= (10.2 ~\\text{cm})(18.3 ~\\text{cm}) \\sqrt{{(0.3 ~\\text{cm})\\over (10.2 ~\\text{cm})}^2 + {(0.5 ~\\text{cm}) \\over (18.3 ~\\text{cm})}^2}\\\\\n&= 7.5 ~\\text{cm}^2\\\\\n&= 8 ~\\text{(rounded to 1 sig fig)}\n\\end{align*}\\]\nAnd the final result would be reported as \\(187 \\pm 8\\) cm\\(^2\\).\nThese uncertainty formulas can be used for more complex calculations by applying multiple formulas to different parts of the expression. For example, suppose you wanted to perform the following calculation with its associated uncertainty:\n\\[ f = b + a x^2\\]\nwhere\n\\[b = 5.1 \\pm 0.2\\] \\[a = 1.8 \\pm 0.1\\] \\[x = 3.92 \\pm 0.05\\]\nWe can first apply the rule for addition from the table:\n\\[\\delta f^2 = \\delta b^2 + \\delta(ax^2)^2\\]\nand then use the rule for powers to calculate \\(\\delta(ax^2)\\): \\[\\delta(ax^2) = a \\delta(x^2) = 2 |x|a \\delta x\\]\nand then insert the second expression into the first to get an expression for the uncertainty on \\(\\delta f\\): \\[\\delta f^2 = \\delta b^2 + (2 |x|a \\delta x)^2\\]\nHere is how we could make python perform the calculation.\n\nfrom numpy import sqrt\nb = 5.1\ndb = 0.2\na = 1.8\nda = 0.1\nx = 3.92\ndx = 0.05\nf = b + a * x**2\ndf = sqrt(db**2+ (2 * x * a * dx)**2)\nprint(f\"f = {f:5.1f} +- {df:0.1f}\")\n\nf =  32.8 +- 0.7"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#python-skills",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#python-skills",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Python Skills",
    "text": "Python Skills\n\nSimple Calculations\nIn this lab you will need to perform simple calculations in Python. When performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\n\na = 5.0\nb = 3\nc = a + b\n\n\n\nBig Numbers\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\n\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzmann constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}~{\\text{m}^2~ \\text{kg}\\over \\text{s}^2~ K} \\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small numbers. (Numbers of both variety show up frequently in physics!)\n\nkB = 1.38e-23\n\n\n\nMathematical Calculations\nMost mathematical calculations that you’ll want to perform are straightforward. Use plus (+) to add, minus (-) to subtract, slash (/) to divide and asterisk (*) to multiply. There are a few other mathematical operations that are not as straightforward. Some of these are shown below.\n\na = 20\nb = 10\nc = a + b # Add \nd = a/b   # Divide\nr = a//b  # Integer Division\nr = a % b # Remainder Division\ne = a * b \nf = c**4  # Raise a number to a power.\n\n\n\nPython functions\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are placed inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x. \\[f(x)\\]\nIn the cell below, you will find several useful Python functions.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\nIn addition to Python’s native collection of mathematical functions, there is also a numpy module (pronounced “num-pie”, short for numerical python) with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The numpy module comes with every installation of python and can be imported (i.e. activated) using the import numpy as np command. After the module has been imported, any function in the module is called using np.function() where function is the name of the function. Here is a list of commonly-used functions inside the numpy module:\n\nimport numpy as np\nnp.sqrt(4)\nnp.ceil(4.3)\nnp.cos(1.5)\nnp.sin(1.5)\nnp.tan(3.14)\nnp.arcsin(1)\nnp.arccos(1/2)\nnp.arctan(2)\nnp.degrees(6.28)\nnp.e\nnp.exp(5)\nnp.log(200)\nnp.log10(1000)\nnp.radians(360)\nnp.pi\n\n\n\nDisplaying Results\nPython won’t display the result of a calculation unless it is told to. To tell python to display a result, you should use the print command. Often you will want to print a sentence with the value of a variable inserted at the appropriate place. This is done using something called an “f”-string. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} m/s and the speed of my car is {v} m/s\")\n\nThe speed of light is 300000000.0 m/s and the speed of my car is 5.0 m/s\n\n\nThat’s a clever way to insert a numerical value into a string, but the value of the speed of light is still displaying too many digits. To specify how the number should be formatted place a : after the variable name followed by a formatting tag.\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nThe structure of the stuff inside of the curly braces is {variable:formatcode}; variable holds the value to be displayed and formatcode indicates how the variable should be formatted when it is printed. The f in :4.2f indicates that the variable should be displayed as a float and the 4.2 indicates that four spaces should be allocated to display the number and no more than 2 numbers after the decimal should be displayed. A selection of some commonly-used format codes is given below.\n\nA summary of common format codes.\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:6s}\nDisplay as a string, allocating 6 total spaces for it. If the string is longer than 6 spaces, it will display the entire string with no extra white space. If the string is shorter than 6 spaces, it will pad the string with whitespace until it is 6 spaces long.\n\n\n\n\n\nErrorbar Plots\nIn this lab you’ll need to plot a small number of data points with error bars attached to them to indicate their associated uncertainties. To make a plot you’ll need to use a module called matplotlib. More specifically, you must import the pyplot function inside of matplotlib. It is customary to use plt as an alias for pyplot, as shown below.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n\nTo make plots with error bars use matplotlilb’s errorbar function. This function has two required arguments: a list of the points’ x-coordinates and a list of the points’ y-coordinates. (A list is created using square brackets in python ([]) ) You can choose to add error bars on the x or y axis using the keyword arguments xerr and yerr. For example, if two measurements of \\(g\\) were taken with their uncertainties, a plot of their values with errorbars can be produced like this:\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n\nx = [1,2] # Just use 1 and 2 to give the two points some separation\ng = [9.7,10.2]\n\ny_error = [0.2,0.4] # Different error for each point\n\nplt.errorbar(x,y, fmt = 'ro',markersize = 12,yerr=y_error,capsize = 8)\nplt.title(\"Experimental values of g\")\nplt.xlabel(\"Experiment number\")\nplt.ylabel(r\"g (m/s$^2$)\")\n\nText(0, 0.5, 'g (m/s$^2$)')\n\n\n\n\n\nSeveral optional arguments can also be used to control the look of the plot. These optional arguments are summarized in the table below:\n\nA Few Common plot keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nfmt\nformat string specifying color and shape of marker\n\n\nmarkersize or ms\nmarker size\n\n\ncapsize\nwidth of the cap on the error bar\n\n\n\nFor a comprehensive list of allowed format string to use with the fmt argument see the section entitled “Format Strings” here"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#markdown-tables",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#markdown-tables",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Markdown Tables",
    "text": "Markdown Tables\nTables are often useful for presenting data. You can make a table in a jupyter notebook using the following syntax\n|t (s)       | v (m/s)     |\n|------------|-------------|\n| 0          | 10          |\n| 1.2        | 22          |\n| 2.3        | 25          |\n| 3.0        | 38          |\n| 5.5        | 56          |\nwhich will generate the following table:\n\n\n\nt (s)\nv (m/s)\n\n\n\n\n0\n10\n\n\n1.2\n22\n\n\n2.3\n25\n\n\n3.0\n38\n\n\n5.5\n56"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#lab-activity-i-50-pts",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#lab-activity-i-50-pts",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Lab Activity I (50 pts)",
    "text": "Lab Activity I (50 pts)\n\nEquipment:\n\nMetal block and cylinder\nBalance scale.\nCaliper or ruler.\n\n\n\nGoal:\nYou will be given a metal block and a metal cylinder. Both objects are made of the same material. You will be allowed to measure the dimensions and mass of the cylinder but only the dimensions of the block. Your goal is to accurately predict the mass of the block with its associated uncertainty. If the true mass of the block falls within your uncertainty window, the experiment is a success.\nImportant: You cannot directly measure the mass of the block. The instructor will take this measurement.\n\n\nProcedure:\nCarefully follow the steps below to accomplish your task (No calculators allowed. All calculations must be performed in Python!!)\n\nCalculate Density of Cylinder (15 points)\n\nUsing the caliper, measure the dimensions of the metal cylinder. Enter the values and the uncertainties into the code cell provided below.\nAssign uncertainties to the measurements made in step one and record those uncertainties in the code cell provided below.\nUsing the mechanical balance, measure the mass of the cylinder.\nAssign an uncertainty to the mass measurment and record it in the code cell given below.\nCalculate the volume of the cylinder (in units of cm\\(^3\\)) in the code cell below.\n\nCalculate the uncertainty in the volume of the cylinder.\nCalculate the density of the cylinder in units of g/cm\\(^3\\). Note: \\(\\rho = {m \\over V}\\)\nCalculate the uncertainty in the density of the cylinder.\nUse a formatted print statement to display the density of the the cylinder with its associated uncertainty.\n\n\n\nCalculate the Volume of the Block (15 points)\n\nUsing the caliper, measure the dimensions of the metal block. Enter the values in the code cell below.\nAssign uncertainties to the measurements you made and record them in the code cell below.\nCalculate the volume of the block (in units of cm\\(^3\\)) in the code cell below.\nCalculate the uncertainty in the volume of the block.\n\n\n\nCalculate the Mass of the Block (10 points)\n\nCalculate the mass of the block using \\(\\rho = {m \\over V}\\) in units of g/cm\\(^3\\).\nCalculate the uncertainty in the mass of the block.\nCalculate the fractional uncertainty in the mass of the block.\nUse a formatted print statement to display the predicted mass of the block with its associated uncertainty.\n\n\n\nCompare to True Value (10 pts)\n\nHave the teacher or a TA measure the mass of the block to compare against your calculation. Assign the uncertainty in this measurement to be the same as when you measured the mass of the cylinder.\nCalculate the percentage error for your prediction.\nModify the table below to include your results for this experiment.\n\nConclusion: Does your calculation agree with the true value to within the stated uncertainty?\n\n\n\nResults\n\n\n\n\nQuantity\nValue\n\n\n\n\nDensity of Cylinder (with uncertainty):\n__ +- __\n\n\nPredicted mass of block (with uncertainty):\n__ +- __\n\n\nActual mass of block (with uncertainty):\n__ +- __\n\n\nPercent Error:\n—\n\n\n\n\n\nfrom pylab import *\n%matplotlib inline\n\n# Enter values for cylinder diameter, height, and mass. Give estimates of the uncertainties.\nd =              # diameter of cylinder in cm\nun_d =           # uncertainty of cylinder diameter in cm\nh =              # height of cylinder in cm\nun_h =           # uncertainty of cylinder height in cm\nm =              # mass of cylinder in gm\nun_m =           # uncertainty of cylinder mass in gm\n\n# Calculate and print the density and its uncertainty\nV =              # Use equations above to calculate volume of cylinder \nun_V =           # Use equation above to calculate uncertainty in volume\n\nrho =            # Use equation above to calculate density of cylinder\nun_rho =         # Use equation above to calculate uncertainty in density\n\n          # Use a formatted print statement to display your density with its uncertainty. (include the units.)\n\n\n# Block dimensions\nl =           # length of the block in cm\nun_l =        # uncertainty of the length of the block in cm\nw =           # width of the block in cm\nun_w =        # uncertainty of the width of the block in cm\nh_b =         # height of the block in cm\nun_h_b =      # uncertainty of the height of the block in cm\n\n# Compute volume of block with uncertainty\nV_b =         # Calculate volume of block\nun_V_b =      # Calculate uncertainty in volume (can you figure it out from looking at the equation for the cylinder?)\n\n# Compute predicted mass of block\nm_b =         # Use previously-calculate density to calculate mass of the block\nun_m_b =      #Calculate the uncertainty in the mass\n\n          # Use a formatted print statement to display your predicted mass with its uncertainty. (include the units.)"
  },
  {
    "objectID": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#activity-ii-50-points",
    "href": "labs/Lab1-Measurements/L1-Intro_to_Error_Analysis.html#activity-ii-50-points",
    "title": "Lab 1: Measurement and Uncertainty",
    "section": "Activity II (50 points)",
    "text": "Activity II (50 points)\n\nEquipment:\n\nFlexible measuring tape.\nMeter stick.\n\n\n\nGoal:\nCalculate the volume of this room with its associated uncertainty. Compare your results with classmates.\n\n\nProcedure:\n\nUsing the flexible measuring tape, measure the length and width of this room. Using the meter stick, measure the height of this room. Assign uncertainties to all of these measurements. Record your values as variable in the code cell provided below.\nIn the code cell below, calculate the volume of the room.\nCalculate the uncertainty in the volume in the code cell below.\nCalculate the fractional uncertainty in the room as a percentage.\nUse a formatted print statement to display the volume of the room with its associated uncertainty.\nCompare your results with the other groups in class. Enter their volumes (and yours) along with their uncertainties (and yours) in the cell provided below.\nCollect volumes (with uncertainties) for the other groups in the class and make an errorbar plot of all groups’ measurements with their uncertainties.\nLabel your axes and put a title on your plot.\n\nIs your answer consistent with those of the other groups? If not, explain why it isn’t.\n\n\nResponse:\n\n\n# Room dimensions\nlr =           # length of the room in m\nun_lr =        # uncertainty of the length of the room in m\nwr =           # width of the room in m\nun_wr =        # uncertainty of the width of the room in m\nhr =           # height of the room in m\nun_hr =        # uncertainty of the height of the room in m\n\n# Compute volume of the room with uncertainty\nV_r =          # Compute the volume of the room\nun_V_r =       # Compute the uncertainty in the volume.\n\n               # Add a formatted print statement to display the volume with its uncertainty.\n# Make error bar plot of all groups volumes here"
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#skills",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#skills",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "Skills",
    "text": "Skills\nIn this lab you will gain the following skills\n\nConstruct Python dataframes and use them to display datasets.\nConstruct arrays of plots in Python (multiple plots on one canvas).\nUse numpy arrays to perform mathematical calculations on data sets.\nUse \\(\\LaTeX\\) to write simple math equations.\nKnow the meaning of the derivative and partial derivative.\nUse derivatives to propagate uncertainty for moderately complex calculations."
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#background-information",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#background-information",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "Background Information",
    "text": "Background Information\n\nThe Slope of a Function\nMathematical functions describe how one quantity depends on one or more other quantities. For example, the velocity function\n\\[v(t) = 5 t + 2\\]\ngives the relationship between velocity and time.\n\n\n\n\n\nand this function gives the relationship between position and time\n\\[y(t) = 5t^2 -3t + 8\\]\n\n\n\n\n\nThe slope of a function (\\(m\\)) is the rate at which the function changes with its variables. The slope is straightforward to calculate for linear functions: Just pick two points, calculate \\(\\Delta y = y_2 -y_1\\) and \\(\\Delta t = t_2 - t_1\\), and divide them. \\[m = {\\Delta y \\over \\Delta t}\\]\nGenerally, the slope of a function isn’t constant but varies across the domain. The figure below illustrates how the tangent line to a non-linear function varies across the domain.\n\n\n\n\n\nFor those that are interested, the slope of the tangent line of a function can be found by calculating the slope of a function in the limit that the change in \\(x\\) (\\(\\Delta x\\)) becomes infinitely small.\n\n\n\n\n\nTo reiterate: The slope isn’t a single number but rather another function. (The slope for linear functions is also a function, but since it’s a constant we sometimes forget this.) This sloping function can be evaluated at any point to determine the slope of the original function. For example, the slope of the function\n\\[y(t) = 4t - 4.9 t^2\\]\nis given by the sloping function\n\\[y'(t) = {dy(t) \\over dt} = -9.8 t + 4\\]\nThese functions are plotted below to illustrate their relationship.\n\n\n\n\n\nThe notation \\({dy(t) \\over dt}\\) is used to indicate the sloping function corresponding to \\(y(t)\\). (\\(y'(t)\\) is another common way to indicate this function.)\n\n\nThe derivative\nThe sloping function can be found by applying a set of mathematical rules to the function of interest. Most of the first half of calculus are devoted to the learning and mastery of these rules. One of the more common rules is the power rule which applies to polynomial functions. Specifically, if \\(f(x) = a + bx + cx^2 + dx^2 + \\dots = \\sum_n a_n x^n\\), then\n\\[ y(x) = f'(x) = a_n (n - 1) x^{n-1}\\]\nThis rule was used to find the sloping function above. A plot of these two functions is given below.\nTo reiterate: the value of the sloping function (derivative) is equal to the slope of the original function. That’s a derivative.\nThe derivative of some other common functions is given in the table below. Your calculus class will teach you how to find the derivative of more complicated functions than those found in the table.\n\n\n\nFunction (\\(f(x)\\))\nDerivative (\\(y(x) = f'(x)\\))\n\n\n\n\n\\(f(x) = \\sin(a x)\\)\n\\(y(x) = a \\cos(a x)\\)\n\n\n\\(f(x) = \\cos(a x)\\)\n\\(y(x) = -a \\sin(a x)\\)\n\n\n\\(f(x) = \\tan(a x)\\)\n\\(y(x) = a \\sec(a x)^2\\)\n\n\n\\(f(x) = e^{a x}\\)\n\\(y(x) = ae^{a x}\\)\n\n\n\\(f(x) = \\ln(a x)\\)\n\\(y(x) = {a \\over x}\\)\n\n\n\\(f(x) = {a \\over x}\\)\n\\(y(x) = -{a \\over x^2}\\)\n\n\n\n\n\nUsing the derivative to find uncertainty.\nSo how does the derivative help when calculating uncertainty. As a simple reminder: the slope of a function is the ratio of the change in function value to the change in variable value.\n\\[ \\text{slope} = {\\partial f \\over \\partial x} = {\\text{rise} \\over \\text{run}} = {\\delta f \\over \\delta x}\\]\nIf \\(\\delta f\\) is the uncertainty in a calculated value and \\(\\delta x\\) is the uncertainty in the measured value, the equation above provides a way to calculate the uncertainty in the calculated value.\n\\[\\delta f = \\text{slope} \\times \\delta x = {\\partial f \\over \\partial x}\\]\nLet’s consider an example where we measure the frequency (\\(f\\)) of a certain light beam to be \\(f = 4.2 \\pm 0.5 \\times 10^{15}\\) Hz and want to calculate the wavelength \\(\\lambda\\) (with its associated uncertainty).\n\\[ \\lambda(f) = {3 \\times 10^8 \\over f} = 7.14 \\times 10^{-8}~ \\text{m}\\]\nA plot of this function is given below\n\n\n\nUsing the table above to calculate the derivative we find\n\\[ \\lambda'(f) = {\\partial \\lambda \\over \\partial f} = -{3 \\times 10^8 \\over f^2} \\]\nAnd hence, the unceratainty in the wavelength is:\n\\[\\delta \\lambda = {\\partial \\lambda \\over \\partial f} \\delta f \\] \\[ = -{3 \\times 10^8 \\over f^2} \\delta f\\] \\[= -{3 \\times 10^8 \\over (4.25 \\times 10^{15} ~\\text{Hz})^2} (0.5 \\times 10^{15} ~\\text{Hz})\\] \\[ = 8.5 \\times 10^9 ~ \\text{m}\\]\n\n\nPartial Derivatives\nWhen the function of interest has more than one independent variable, derivatives are performed on each variable separately, and all other variables are treated as constants. Derivatives of functions of many variables are called partial derivatives.\nFor example, consider the function:\n\\[f(x,y) = 5 x y^2 + 8 x^2 y\\]\nThe partial derivatives of this function are\n\\[{\\partial f \\over \\partial x} = 5 y^2 + 16 x^2 y\\] \\[{\\partial f \\over \\partial y} = 10 xy + 8 x^2\\]\nThe uncertainty in the calculated values is calculated by first forming the product \\({\\partial f \\over \\partial x_i} \\delta x_i\\) for each independent variables and inserted into the equation below \\[(\\delta f)^2 = ({\\partial f\\over \\partial x} \\delta x)^2 + ({\\partial f\\over \\partial y}\\delta y)^2  + \\dots\\]\nThis is the most important formula for uncertainty propagation and the one we will use going forward.\n\n\nAn Example\nImagine measuring the dimensions and mass of a block with their associated uncertainties:\n\\[l = 5.2 \\pm 0.1 ~\\text{cm}\\] \\[w = 8.4 \\pm 0.3 ~\\text{cm}\\] \\[h = 10.8 \\pm 0.4 ~\\text{cm}\\] \\[m = 345 \\pm 5 ~\\text{grams}\\]\nand proceeding to calculate the density of the block\n\\[\\rho = {m \\over V} = {m \\over l \\times w \\times h}\\]\n\n\n=  0.73 g/cm^3\n\n\nTo calculate the uncertainty, we must first take four derivatives with respect to \\(l\\), \\(w\\), \\(h\\), and \\(m\\):\n\\[ {\\partial \\rho \\over \\partial l} = -{m \\over l^2 w h}\\]\n\\[ {\\partial \\rho \\over \\partial h} = -{m \\over l w h^2}\\]\n\\[ {\\partial \\rho \\over \\partial w} = -{m \\over l w^2 h}\\]\n\\[ {\\partial \\rho \\over \\partial m} = {1 \\over l w h}\\]\nNow we can calculate the uncertainty as\n\\[\\delta \\rho = \\sqrt{({\\partial \\rho \\over \\partial l} \\delta l)^2 + ({\\partial \\rho \\over \\partial w} \\delta w)^2 + ({\\partial \\rho \\over \\partial h} \\delta h)^2 + ({\\partial \\rho \\over \\partial m} \\delta m)^2}\\]\n\\[ = \\sqrt{(-{m \\over l^2 w h} \\delta l)^2 + (-{m \\over l w^2 h} \\delta w)^2 + (-{m \\over l w h^2} \\delta h)^2 + ({1 \\over l w h} \\delta m)^2}\\]\n\\[ = \\sqrt{(-{(345 ~\\text{grams}) \\over (5.42 ~\\text{cm})^2 (8.4 ~\\text{cm}) (10.8 ~\\text{cm})} (0.1 ~\\text{cm}))^2 + (-{(345 ~\\text{grams}) \\over (5.42 ~\\text{cm}) (8.4 ~\\text{cm})^2 (10.8 ~\\text{cm})} (0.3 ~\\text{cm}))^2 + (-{(345 ~\\text{grams}) \\over (5.42 ~\\text{cm}) (8.4 ~\\text{cm}) (10.8 ~\\text{cm})^2} (0.4 ~\\text{cm}))^2 + ({1 \\over (5.42 ~\\text{cm}) (8.4 ~\\text{cm}) (10.8 ~\\text{cm})} (5 ~\\text{grams}))^2}\\]\nIn the code cell below we use python to calculate this uncertainty. Note that we use a formatted print statement to display the uncertainty to one significant figure.\n\nfrom numpy import sqrt\nm = 345\ndm = 5\nl = 5.2\ndl = 0.1\nw = 8.4\ndw = 0.3\nh = 10.8\ndh = 0.4 \n\nrho = m/l/w/h\ndrdl = -m/l**2/w/h\ndrdw = -m/l/w**2/h\ndrdh = -m/l/w/h**2\ndrdm = 1/l/w/h\ndrho = sqrt((drdl * dl)**2 + (drdw * dw)**2 + (drdh * dh)**2 + (drdm * dm)**2)\nprint(f\"The density of the block is {rho:5.2f} +- {drho:4.2f} g/cm^3\")\n\nThe density of the block is  0.73 +- 0.04 g/cm^3"
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#python-skills",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#python-skills",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "Python Skills",
    "text": "Python Skills\n\nDataFrames\nA dataframe is a data structure that organizes data into a 2-dimensional table of rows and columns, similar to a spreadsheet. A dataframe can be initiated in Python using the pandas.DataFrame() function (case sensitive). For example, suppose that you used the accelerometer on your phone to gather the following data.\n   time     gFx     gFy     gFz  \n0  0.007 -0.0056 -0.0046  1.0120  \n1  0.008  0.0007  0.0024  1.0022  \n2  0.008  0.0000  0.0059  1.0039  \n3  0.009  0.0054 -0.0022  1.0032  \n4  0.009 -0.0015 -0.0056  1.0042  \n5  0.009  0.0037 -0.0020  0.9951  \n6  0.010 -0.0020 -0.0020  1.0020  \n7  0.014  0.0090 -0.0024  1.0159  \n8  0.015  0.0012 -0.0037  1.0100  \n9  0.017 -0.0115 -0.0020  1.0012 \nThis data can be loaded into a dataframe like this.\n\nfrom pandas import DataFrame\nimport numpy as np\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(np.transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"])\ndisplay(elevator_data)\n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\n0\n0.007\n-0.0056\n-0.0046\n1.0120\n\n\n1\n0.008\n0.0070\n0.0024\n1.0022\n\n\n2\n0.008\n0.0000\n0.0059\n1.0039\n\n\n3\n0.009\n0.0054\n-0.0022\n1.0032\n\n\n4\n0.009\n-0.0015\n-0.0056\n1.0042\n\n\n5\n0.009\n0.0037\n-0.0020\n0.9951\n\n\n6\n0.010\n-0.0020\n-0.0020\n1.0020\n\n\n7\n0.014\n0.0090\n-0.0025\n1.0159\n\n\n8\n0.015\n0.0012\n-0.0037\n1.0100\n\n\n9\n0.017\n-0.0115\n-0.0020\n1.0012\n\n\n\n\n\n\n\nThe display command can then be used to display the dataframe to screen. The keyword argument columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"] will assign names to the columns of the dataframe. The rows also have names attached but since these names were not specified, they defaulted to the integers 0 - 9. If you want to assign different names to the rows of your dataframe, add the keyword argument index = when you call DataFrame, like this\n\nfrom pandas import DataFrame\nimport numpy as np\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(np.transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\ndisplay(elevator_data)\n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\nA\n0.007\n-0.0056\n-0.0046\n1.0120\n\n\nB\n0.008\n0.0070\n0.0024\n1.0022\n\n\nC\n0.008\n0.0000\n0.0059\n1.0039\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\n\n\nE\n0.009\n-0.0015\n-0.0056\n1.0042\n\n\nF\n0.009\n0.0037\n-0.0020\n0.9951\n\n\nG\n0.010\n-0.0020\n-0.0020\n1.0020\n\n\nH\n0.014\n0.0090\n-0.0025\n1.0159\n\n\nJ\n0.015\n0.0012\n-0.0037\n1.0100\n\n\nK\n0.017\n-0.0115\n-0.0020\n1.0012\n\n\n\n\n\n\n\nNow the names of your rows will be “A” through “K”\n\n\nMultiple Plots\nLast week we learned how to generate a single, simple plot. Often you may want to generate multiple, independent plots in the same figure. To do this, first we must use the figure function which generates the canvas upon which the plots will appear. Assign this object to a variable so you can refer to it later. To create each subplot, the fig.add_subplot(rows,columns, plot_number) function is used. There are three arguments to this function; the first two indicate the shape of the grid and the third indicates which position on the grid this plot will be assigned.\nfig.add_subplot(rows,columns,plot_location)\nAfter the axes object has been created, we can call the plot, or errorbar function again, and a plot will be generated at its location. Here is an example that will generate two plots side by side.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(1,2,1)\nax2 = fig.add_subplot(1,2,2)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\nPay close attention to the add_subplot function. ax1=add_subplot(1,2,1) will generate a \\(1\\) x \\(2\\) grid of plots and ax1 will correspond plot at the 1st location. Below is an example of a more advanced array of plots. Pay close attention to the add_subplot functions until you understand.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2= fig.add_subplot(2,2,3)\nax3 = fig.add_subplot(2,2,4)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nax3.plot(r,energyTwo,marker = 'o',color = 'r')\nax3.set_xlim(0.5,4.0)\nax3.set_ylim(-2,5)\nax3.set_xlabel(\"Separation Distance\")\nax3.set_ylabel(\"Energy\")\nax3.set_title(\"Lennard-Jones Potential\")\nplt.tight_layout()\n\n\n\n\nAlso notice the set_xlim, set_ylim, set_xlabel etc methods that were used to customize each individual plot. There are a host of other methods available for further customization.\nThis website has a comprehensive list of them.\n\n\nNumpy Arrays\nOften in science you’ll be working with more than one data point at a time. For example, consider the data shown below of a ball that is dropped from several different initial heights.\n\n\n\n\n\n\n\n\n\nInitial height (meters)\nFall time (seconds)\n\n\n\n\n0\n2.0\n0.64\n\n\n1\n2.5\n0.71\n\n\n2\n3.0\n0.78\n\n\n3\n3.5\n0.85\n\n\n4\n4.0\n0.90\n\n\n\n\n\n\n\nData like this should be stored in a numpy (“num-pie”) array, like this:\n\nimport numpy as np\n\nt = np.array([0.64,0.71,0.78,0.85,0.90])\ny = np.array([2.0,2.5,3.0,3.5,4.0])\n\nThe benefit of storing your data in arrays is that mathematical calculations are “vectorized” which means that the mathematical operation is performed across the entire data set without needing a loop. For example, the equation \\(g = {2 y \\over t^2}\\) could be used to find the acceleration due to gravity for all of the data points like this:\n\nimport numpy as np\n\nt = np.array([0.64,0.71,0.78,0.85,0.90])\ny = np.array([2.0,2.5,3.0,3.5,4.0])\n\ng = 2 * y/t**2\nprint(g)\n\n[9.765625   9.91866693 9.86193294 9.68858131 9.87654321]\n\n\nIf you need to use mathematical function like square roots or trigonometric functions, you should always import them from numpy and not math."
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#mathrmlatex",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#mathrmlatex",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "\\(\\mathrm{\\LaTeX}\\)",
    "text": "\\(\\mathrm{\\LaTeX}\\)\nOften you will want to include math equations as part of your explanation/text. Below is an example of what your math should and should not look like.\n\n\\(|\\vec{v}| = \\sqrt{v_x^2 + v_y^2}\\) (like this)\n\nv = sqrt(vx^2 + vy^2) (not like this)\n\nTo make your math equations look like the first example, you must enclose your math equation in “$$”, one pair at the beginnning of the equation and one pair at the end. Enclosing your expression in double dollar signs will put the expression on its own line. To place the expression in the middle of a sentence (inline) you’ll need to enclose the expression in single dollar signs. To generate the math symbols that often show up in equations, you’ll need to know the correct syntax. A table of commonly used math symbols is given below.\n\n\n\n\n\n\n\n\nMath symbol\nExample\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\nSubscript\n\\(v_x\\)\nv_x\n\n\nPowers\n\\(v^2\\)\nv^2\n\n\nPowers with more than one digit\n\\(v^{10}\\)\nv^{10}\n\n\nSquare root\n\\(\\sqrt{a + b}\\)\n\\sqrt{a + b}\n\n\nFractions\n\\(\\frac{a}{b}\\)\n\\frac{a}{b}\n\n\nVectors\n\\(\\vec{x}\\)\n\\vec{x}\n\n\nIntegrals\n\\(\\int x^2 dx\\)\n\\int x^2 dx\n\n\nPartial Derivatives\n\\({\\partial f \\over \\partial x}\\)\n{\\partial f \\over \\partial x}\n\n\nSummations\n\\(\\sum_{i = 1}^{10} x_i^2\\)\n\\sum_{i = 1}^{10} x_i^2\n\n\nInfinity\n\\(\\infty\\)\n\\infty\n\n\n\nYou can include Greek letters in your expressions if you know the corresponding syntax. The table below shows some of the more common Greek letters used in physics.\n\n\n\nGreek Letter\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\Delta\\)\n\\Delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\nA more comprehensive list of math symbols available can be found here"
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#activity-i-the-pendulum-50-pts",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#activity-i-the-pendulum-50-pts",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "Activity I: The pendulum (50 pts)",
    "text": "Activity I: The pendulum (50 pts)\n\nEquipment needed:\n\nPendulum. (We have some pre-made, or you can tie a string to a mass)\nMetal support stand for pendulum to swing from.\nPhotogate.\n\n\n\nGoal:\nBy taking measurements on a simple pendulum, calculate the acceleration due to gravity with its associated uncertainty. Compare to the known value for Rexburg.\n\n\nProcedure:\n\nAssemble five pendulums of different lengths, with the lengths ranging from \\(0.25\\) m to \\(2.0\\) m.\n\nFor each pendulum, perform the following:\n\nMeasure the distance from the support point to the center of the pendulum. This is the length of the pendulum \\(L\\). Assign an uncertainty to this measurement.\nRelease the pendulum from a small initial angle (no bigger than \\(15^\\circ\\) from the vertical) and use the photogate to measure the period \\(T\\) of the pendulum with its associated uncertainty. (The period of a pendulum is the time it take to make one full cycle.)\nPlace all of your lengths and periods and their uncertainties into numpy arrays.\n\nCalculate the acceleration due to gravity (\\(g\\)) using \\(g = {4 \\pi^2 L \\over T^2}\\).\nUsing the methods discussed above determine the equation for calculating the uncertainty in \\(g\\). Use \\(\\LaTeX\\) syntax to complete the math equation below \\[ \\delta g = \\]\nCalculate the uncertainty and fractional uncertainty in \\(g\\) in the code cell below.\nPut your data in a dataframe and display the dataframe to visually verify that it has 10 rows and 6 columns. The columns should be \\(L\\), \\(T\\), \\(g\\) and their uncertainties. Give the appropriate names.\nConstruct a multi-figure plot containing two plots. The first plot should be period vs length and the other plot should be g vs. length. The points on both plots should have error bars attached.\nAdd axes labels and titles to both of your plots.\nAnalyze the results to answer the following questions:\n\nWhich result has the lowest uncertainty? Can you explain why?\n\nWhat function do you think best represents the relationship between \\(L\\) and \\(T\\)?(We will study curve-fitting in a later lab.)\n\nThe accepted value of \\(g\\) for Rexburg is \\(g = 9.80056\\) m/s\\(^2\\). Do your calculations agree with this value to within your calculated uncertainties?\n\n\nResponse:\n\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n%matplotlib inline\n\n\n\nT =    # Create array of period values.\nun_T =  # Create array of uncertainties in the period measurements.\nL =     # Create array of length values.\nun_L =  # Create array of uncertainties in the length measurements.\ng =     # Calculate g for the whole data set.\nun_g =   # Calculate the uncertainty in g for the whole data set.\nfrac_un =  # Calculate fractional uncertainties.\n\ndf =            # Creat a dataframe of your data. Give the columns appropriate names\ndisplay(df) # Display the dataframe\n\n# Construct a multi-figure plot below.\nfig = plt.figure()            \n\nplt.show()"
  },
  {
    "objectID": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#activity-ii-50-points",
    "href": "labs/Lab2-Propagation_of_Uncertainty_I/L2-Propagation_of_UncertaintyI.html#activity-ii-50-points",
    "title": "Lab 2: Propagation of Uncertainty I",
    "section": "Activity II (50 points)",
    "text": "Activity II (50 points)\n\nEquipment needed\n\nMeter Stick\nStopwatch (the one on your phone will do fine.)\nTennis ball.\n\n\n\nGoal\nBy measuring the fall time for an object in free fall, calculate the acceleration due to gravity here in Rexburg. You’ll be dropping a tennis ball from 10 different heights and measuring the fall time for each.\n\n\nProcedure\n\nFind a location in the building that will allow the greatest drop distance for the tennis ball. (The front foyer is a good choice.) You’ll be dropping the tennis ball from 10 different heights starting at \\(1\\) meter and ending at the largest height you can achieve. Measure the height.\nUsing a stopwatch, measure the fall time with its associated uncertainty. Record the values in the code cell provided below. Note: typical reaction times are around \\(0.25\\) s.\nRepeat steps 1 and 2 ten more times to obtain ten data points. The ball should be dropped from a different height for each trial. Place your heights and drop times and their uncertainties in numpy arrays.\nUsing the equation below, calculate the acceleration due to gravity for all 10 data points. \\[ g = {2 h \\over t^2}\\]\nUsing the methods discussed above determine the equation for calculating the uncertainty in \\(g\\). Use \\(\\LaTeX\\) syntax to complete the math equation below \\[ \\delta g = \\]\nUsing the equation from step 5, calculate the uncertainty in \\(g\\) in the code cell below for all 10 data points.\n\nPut your data in a dataframe and display the dataframe to visually verify that it has 10 rows and 6 columns.\nConstruct a multi-figure plot containing two plots. The first plot should be \\(g\\) vs trial number and the other plot should be \\(g\\) vs. fall time. The points on both plots should have error bars attached.\nAdd axes labels and titles to both of your plots.\nUsing your results, answer the following questions:\n\nAre your ten g values consistent with one another to within their stated uncertainties. Explain.\nWhat function do you think describes the relationship between the fall distance and the fall time. (We will study curve-fitting in a later lab.)\nWhich of your g values agree with the accepted value of g for Rexburg given in the first exercise.\n\n\nResponse:\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n%matplotlib inline\n\ntrial = np.array([1,2,3,4,5,6,7,8,9,10])\nh =   # Construct an array of the fall distances\nun_h =     # Construct an array of the uncertainties in the fall distances.\nt =       # Construct an array of the measured fall times.\nun_t =        # Construct an array of the uncertainties in the fall times.\ng =               # Calculate g for the entire data set.\nun_g =            # Calculate the uncertainty in g\nfrac_g =          # Calculate the fractional uncertainty.\n\ndf = # Create a dataframe of your data. Give the columns appropriate names\ndisplay(df) # Display your dataframe\n\n\n# Construct plots\nfig = plt.figure()            \n\n\n\n\n\nplt.show()"
  },
  {
    "objectID": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#skills-youll-gain",
    "href": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#skills-youll-gain",
    "title": "Lab 3: Propagation of Uncertainty Part II",
    "section": "Skills you’ll gain",
    "text": "Skills you’ll gain\n\nUse basic LaTeX syntax to write simple mathematical equations.\nUse sympy to calculate derivatives.\nPropagate uncertainty for complex equations using the equation \\[ \\delta q =  \\sqrt{({\\partial q \\over \\partial a} \\delta a)^2 + ({\\partial q \\over \\partial b} \\delta b)^2 + \\dots}\\]"
  },
  {
    "objectID": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#background",
    "href": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#background",
    "title": "Lab 3: Propagation of Uncertainty Part II",
    "section": "Background",
    "text": "Background\nLast week we learned about partial derivatives and how they can be used to calculate uncertainties in calculated quantities. The most important equation for propagation of uncertainty is \\[ \\delta q =  \\sqrt{({\\partial q \\over \\partial a} \\delta a)^2 + ({\\partial q \\over \\partial b} \\delta b)^2 + \\dots}\\] It’s not hard to find a situations that result in very difficult (and very messy) partial derivatives. This week we’ll continue to use this equation to propagate uncertainty but we’ll use Python to calculate the derivatives. Python can calculate derivatives for you using a module called sympy (short for symbolic python). To use sympy to calculate derivatives, follow the the following steps.\n\nStep 1: Define the variables that are in the expression that you want to differentiate.\nStep 2: Define the expression that you want to differentiate.\nStep 3: Use sympy’s diff function to perform the differentiation.\nStep 4: Use subs to evaluate the derivative for given value of the variables.\n\nTo see how this works, let’s follow these steps to differentiate the following function. \\[z(x,y) = {x^2 \\over y}\\]. Study the code cell below to see how this is done.\n\nimport sympy as sp\nsp.init_printing(use_unicode = True)\nx,y = sp.symbols(\"x y\")  # Step 1: Define variables \n\nz = x**2/y  # Step 2: Define expression\ndisplay(z)\nzprime = sp.diff(z,x)  # Step 3: Use 'diff' to differentiate.\ndisplay(zprime)\nsubsDict = {x:5,y:3} # Step 4 part 1: Define a dictionary with the substitution rules: x-&gt;5, y-&gt; 3\nresult = zprime.subs(subsDict)  #Step 4 part 2: Evaluate the derivative at x = 5, y = 3\nprint(result)\n\n\\(\\displaystyle \\frac{x^{2}}{y}\\)\n\n\n\\(\\displaystyle \\frac{2 x}{y}\\)\n\n\n10/3\n\n\nNotice that curly braces ({}) were used to define the set of substitution rules. Make sure to not mistakenly use parenthesis or square brackets in their place or the substitution will not work."
  },
  {
    "objectID": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#activity-i-exit-speed-50-pts",
    "href": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#activity-i-exit-speed-50-pts",
    "title": "Lab 3: Propagation of Uncertainty Part II",
    "section": "Activity I: Exit Speed (50 pts)",
    "text": "Activity I: Exit Speed (50 pts)\n\nEquipment needed:\n\nCannon and plunger\nSpherical steel ball (projectile)\nMeter Stick\n\n\n\nGoal:\nDetermine the speed with which the projectile leaves the cannon for all three launch settings with their associated uncertainties.\n\n\nProcedure:\n\nSet your cannon on the floor or table and set the launch angle to \\(90^\\circ\\) (straight up)\nMeasure the distance from where the sphere exits the launcher to the peak of its trajectory. Record the value and the uncertainty in the code cell provided below.\nIn the cell below, record the best value of “g” from the previous lab with its associated uncertainty.\nYou may remember the following kinematic equation: \\[ v_f^2 = v_i^2 - 2 g h\\]. Do the algebra needed to solve this equation for \\(v_i\\). Use \\(\\LaTeX\\) syntax to complete the equation below \\[ v_i = \\]\nOn line 8 of the code cell below, define sympy symbols for g and delta_h.\nOn line 9 of the code cell below, enter the expression you found in step 4 for the initial velocity. To calculate a square root, use sp.sqrt()\nTo calculate the uncertainty in the initial velocity, you need to take two derivatives of the function that you found in step 4; \\({\\partial v_i \\over \\partial g}\\) and \\({\\partial v_i \\over \\partial h}\\). Use \\(\\LaTeX\\) syntax to complete the mathematical statements below with the expressions for these derivatives. \\[{\\partial v_i \\over \\partial g} = \\] \\[{\\partial v_i \\over \\partial h} = \\]\nOn lines 11 and 12 of the code cell below, use sympy to calculate the derivatives of vi with respect to g and h.\nOn lines 16 of the code cell below, substitute values for the symbols to get a value for the initial velocity.\nNow execute the cell below and compare python’s derivatives to your hand-written ones. (You may need to comment out some lines that haven’t been completed yet)\nThe expression for the uncertainty for \\(v_i\\) is \\[ \\delta v_i =  \\sqrt{({\\partial v_i \\over \\partial g} \\delta g)^2 + ({\\partial v_i \\over \\partial h} \\delta h)^2}\\] Perform this calculation on line 17 in the code cell below to obtain a value for the uncertainty in \\(v_i\\).\n\nAdd a formatted print statement to display the initial velocity and its associated uncertainty (with units).\n\n\nimport sympy as sp\n# Launch Parameters\nh =           # distance from exit point to peak\nun_h =        # uncertainty of the distance\ng_val =           # acceleration due to gravity (refer to last week's results)\nun_g =        # uncertainty in g (refer to last week's results)\n\ng,dh =        # define sympy symbols for g and delta_h (Line 8)\nvi =          # Calculate the initial speed (Line 9). \n\ndvdg =   # Take the derivative with respect to g  (Line 11)\ndvdh =  # Take the derivative with respect to h (distance to peak) (Line 12)\ndisplay(dvdg)  # Display the derivatives to check that you did it right.\ndisplay(dvdh)\n\ninitialV = # Substitute numbers in for the symbols.  (line 16)\nΔvi =  # Line 17\n\n# Add a formatted print statement here to display your results."
  },
  {
    "objectID": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#activity-ii---projectile-motion-prediction-50-points",
    "href": "labs/Lab3-Propagation_of_Uncertainty_II/L3-Propagation_of_UncertaintyII.html#activity-ii---projectile-motion-prediction-50-points",
    "title": "Lab 3: Propagation of Uncertainty Part II",
    "section": "Activity II - Projectile Motion Prediction (50 points)",
    "text": "Activity II - Projectile Motion Prediction (50 points)\n\nEquipment needed\n\nLauncher Cannon\nSpherical Steel Projectile\nMeter Stick\n\n\n\nGoal\nPredict the landing location for a launched projectile with its associated uncertainty. Verify that observed results agree with your prediction to within your stated uncertainty.\n\n\nProcedure\n\nSetup\n\nSet your cannon on a table and aim it in a direction so that the projectile won’t hit anything (or anyone).\nChoose an initial launch angle and speed setting. Then adjust your cannon to match these choices. Record your launch angle with its associated uncertainty (in radians) in the code cell below.\nTransfer the initial velocity and uncerainty that you found from activity I into the code cell below.\nMeasure the distance from the ground to the projectile’s point of exit. Record this number with its associated uncertainty in the code cell below.\n\nOn line 14 of the code cell below, define symbols for the variables \\(v_i\\), \\(y_i\\), \\(\\theta\\),\\(g\\), and \\(t\\).\nOn line 15 of the code cell below, define a dictionary containing the substitution rules for \\(v_i\\), \\(y_i\\), \\(\\theta\\), and \\(g\\).\n\n\n\nCalculations\n\nYou may recall the following kinematic equations from your PH121 class. \\[x_f = x_i + v_i \\cos(\\theta) t\\] \\[y_f = y_i + v_i \\sin(\\theta) t -{1\\over 2} g  t^2\\] Use the second of these equations to find an expression for the projectile’s flight time in terms of \\(y_i\\), \\(v_i\\), \\(\\theta\\), and \\(g\\). Use \\(\\LaTeX\\) syntax to complete the equation below with your answer. Hint: You will have to solve a quadratic equation.\\[ t = \\]\nEnter the expression that you found in part 5 on line 18 of the code cell below. Use sp.sqrt() for square root expressions and sp.sin() for sine expressions.\n\nOn line 19 of the code cell, substitute values for \\(v_i\\), \\(y_i\\), \\(\\theta\\), and \\(g\\) to obtain a value for the flight time.\nTo find the uncertainty in the flight time, you’ll need to evaluate four partial derivatives: \\({\\partial t \\over \\partial v_i}\\), \\({\\partial t \\over \\partial \\theta}\\), \\({\\partial t \\over \\partial g}\\), and \\({\\partial t \\over \\partial y_i}\\). We’ll let python calculate these derivatives (don’t do them by hand!), following the same pattern shown in activity I. Fill in lines 21 - 24 in the code cell below with the appropriate code to calculate the four relevant derivatives. (They will look similar to lines 11 and 12 from the code cell above.)\nThe expression for the uncertainty in the flight time is given by:\\[ \\delta t = \\sqrt{({\\partial t \\over \\partial v_i} \\delta v_i)^2 + ({\\partial t \\over \\partial \\theta} \\delta \\theta)^2 + ({\\partial t \\over \\partial y_i} \\delta y_i)^2 + ({\\partial t \\over \\partial g} \\delta g)^2}\\] Fill in line 27 in the code cell below with the appropriate code to calculate this expression. (It will be similar to line 17 from the code cell above)\nNow that you have the flight time with its uncertainty, you can use the first kinematic equation from above to calculate the projectile’s landing location. Use \\(\\LaTeX\\) syntax to complete an expression for the landing location \\(x_f\\) in terms of \\(v_i\\), \\(\\theta\\), and \\(t\\). \\[x_f = \\]\nEnter the expression that you found in part 9 on line 33 of the code cell below.\nOn line 34 of the code cell, substitute values for \\(v_i\\), \\(y_i\\), \\(\\theta\\), \\(g\\), and \\(t\\) to obtain a value for the landing location.\nTo find the uncertainty in the landing location, you’ll need to evaluate three partial derivatives: \\({\\partial x_f \\over \\partial v_i}\\), \\({\\partial x_f \\over \\partial \\theta}\\), and \\({\\partial x_f \\over \\partial t}\\). We’ll let python calculate these derivatives, following the same pattern from activity I. Fill in lines 36 - 38 in the code cell below with the appropriate code to calculate the three relevant derivatives.(They will look similar to lines 11 and 12 from the code cell above.)\nThe expression for the uncertainty in the landing location:\\[ \\delta x_f = \\sqrt{({\\partial x_f \\over \\partial v_i} \\delta v_i)^2 + ({\\partial x_f \\over \\partial \\theta} \\delta \\theta)^2 + ({\\partial x_f \\over \\partial t} \\delta t)^2}\\] Fill in line 43 in the code cell below with the appropriate code to calculate this expression. (It will be similar to line 17 from the code cell above)\nAdd formatted print statements to display the flight time and landing location with their associated uncertainties (include units).\nEvaluate the code cell below and observe the results. By experimenting with the uncertainties in measured values, can you determine which variable has the greatest affect on the uncertainty in the projectile’s landing location?\n\n\nimport sympy as sp\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\ninitialV =            # Initial speed of projectile.  \nδ_vi =          # Uncertainty in initial speed of projectile.\ntheta =            # Launch angle (Must be in Radians!!)\nδ_θ =         # Uncertainty in launch angle (Must be in radians)\nh =            # Initial height of projectile (meters).\nδ_h =         # Uncertainty in intial height (meters).\ngrav =            # Acceleration due to gravity (m/s^2). (Use value obtained in previous lab)\nδ_g =         # Uncertainty in acceleration due to gravity (m/s^2)\n\nvi,θ,yi,g,t =  # Define the symbols you'll need. (Line 14)\nvalues = # Define the dictionary with the substitution rules (Line 15)\n\n\ntime =        # Line 18\ntFlight=   # Substitute values to obtain a number for the flight time. (Line 19)\n\ndtdv =   # Derivative with respect to vi (Line 21)\ndtdθ =    # Derivative with respect to θ (Line 22)\ndtdy =   # Derivative with respect to yi (Line 23)\ndtdg =    # Derivative with respect to g (Line 24)\n\n\nδt =      # Calculate uncertainty in flight time (Line 27)\n\nvalues[t] = tFlight  # Add flight time to dictionary of values\n\nxf =   # define range function (Line 33)\nlandingloc =   # Substitute values to obtain the landing location (Line 34)\n\ndxdvi =   # Derivative with respect to vi (Line 36) \ndxdθ =     # Derivative with respect to θ (Line 37)\ndxdt =     # Derivative with respect to time (Line 38)\n\n\n\n# Calculate uncertainty in landing location\nδloc =   # Line 43\n\n\n\nExperiment and Analysis\n\nPut a piece of carbon paper on the floor at your predicted landing location. Draw a circle on the carbon paper to reflect the uncertainty in your prediction. Then launch the projectile and observe where it lands. Measure the distance to the landing location with its associated uncertainty and record it in the second code cell below. Put your names on the carbon paper and hand it in to B. Nelson.\nUsing a stop watch, measure the time of flight with it’s associated uncertainty. (Don’t forget to consider your reaction time when assigning the uncertainty.) Record these values in the code cell below.\nConstruct a multi-figure plot containing two plots. The first plot should display your predicted flight time next to your observed flight time. The second plot should display your predicted landing location next to your observed landing location. Both plots should have error bars on them.\nAdd axes labels and titles to both of your plots.\nEvaluate the code cell and, after observing the results, answer the following questions about your experiment in the area marked “Response” below:\n\nDo your predictions and measurements agree to within your stated uncertainty?\nIf your observations did not match your predictions to within your stated uncertainties, comment on why you think it was?\n\n\nResponse:\n\n\n\nobs_xf =  #Record your observed landing location.\nδ_obs_xf =  # Record the uncertainty in your observed landing location.\nobs_t =     # Record your observed flight time.\nδ_obs_t =   # Recored the uncertainty in your observed flight time.\n\n# Add figures here."
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#skills",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#skills",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Skills",
    "text": "Skills\n\nUse Python to plot statistical distributions and histograms.\nUse Python to calculate the mean, standard deviation, and standard deviation of the mean for a data set.\nUse Python to read data from a file.\nExplain the difference between standard deviation and standard deviation of the mean.\nUse statistical information to report uncertainties."
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#background-information",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#background-information",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Background Information",
    "text": "Background Information\n\nStatistical Distributions\nWe’ve learned that all measurements have uncertainties associated with them. This means that when a measurement (or experiment) is repeated, the obtained value is different every time. Statisticians call this a random variable, but the numbers aren’t as random as you might think. You might think that the word random means that the value can be anything; any number at all from \\(-\\infty \\rightarrow \\infty\\) but that’s not what we typically mean. Instead, random in this context means a number that is random but subject to some probability rules.\nThe rules for deciding what random numbers are allowed are contained in a mathematical function called a probability distribution. The Gaussian (or Normal) distribution and Gamma distributions (pictured below) are two common distributions . (Students will no doubt be familiar with the term “bell curve”.)\n\n\n\n\n\nThe numbers on the horizontal axis are the possible random numbers and the height of the function indicates the probabilities. For example, for the Gaussian distribution numbers near 5 will be more likely to appear than numbers much greater or less than 5. Conversely, numbers greater than 8 and less than 2 will be quite unlikely to occur. Numbers between 6 and 8 (or 2 and 4) are less likely than numbers between 4 and 6 but more likely than numbers greater than 8 (or less than 2). You get the idea. The gamma distribution isn’t symmetric like the Gaussian. Numbers far above the peak location are more likely than numbers far below the peak location. The lower pane in the figure above is 20 random numbers selected (drawn) from this distribution.\nThe mathematical expression for the Normal distribution is given by\n\\[\nf(x) = {1\\over \\sigma \\sqrt{2 \\pi}} e^{-(x- \\mu)^2 \\over 2 \\sigma^2}\n\\]\nThe shape and location of this function are controlled by two numbers: the mean (\\(\\mu\\)) and standard deviation (\\(\\sigma\\)). The mean controls where the peak of the distribution is located and the standard deviation controls the width of the peak. One feature of the normal distribution is that 68% of the data lies between \\(\\mu - \\sigma\\) and \\(\\mu + \\sigma\\). For this reason we often assign the mean to be the expected value and the standard deviation to be the associated uncertainty.\n\n\n\n\n\nSo what does this have to do with uncertainties in scientific experiments? When a scientist performs measurements and gathers data, they are gathering samples from a statistical distribution, usually a Gaussian. This idea is crucial to understanding how statistical distributions describe uncertainty. The challenge is figuring out which Gaussian distribution the data came from.\n\n\nHistograms\nWhen an experiment can be repeated over and over again under identical physical conditions, the data can be visualized using something called a histogram. To construct a histogram, the range of plausible measurement values is first divided into bins. Each measurement is then assigned a bin and the total number of measurements in each bin is updated. The number of measurements in all of the bins can be visualized by plotting a bar for each bin, with the height of the bar indicating how many measurements were in the bin. Below is a histogram for 10 repetitions of an experiment to determine the acceleration due to gravity.\n\n\n\n\n\nTen data points isn’t a lot but you can probably start to form a reasonable guess for the mean(expected value) and standard deviation(uncertainty) of the underlying distribution. As more data is gathered, your estimates for \\(\\mu\\) and \\(\\sigma\\) will update and your confidence in those values increases with it. (Illustrated in the figure below)\n\n\n\n\n\nAs more measurements are performed the level of confidence in the mean and standard deviation increase\n\n\n\n\nThe location of the distribution’s peak would be the expected value and the spread of the peak (at about half the max height) would be the associated uncertainty.\n\n\nMean\nThe peak of the distribution is located at the mean (\\(\\mu\\)) and can be calculated from a data set using the following expression\n\\[\n\\begin{align*}\n\\mu &= {x_1 + x_2 + \\dots\\over N}\\\\\n&= {1\\over N}\\sum_{i=1}^N \\\\\n\\end{align*}\n\\]\nThe mean should be used as the expected value when reporting results. The uncertainty in the mean will decrease as more measurements are added to the data set.\n\n\nStandard Deviation\nThe standard deviation indicates the spread in the distribution and can be calculated using the following expression \\[\n\\sigma = \\sqrt{ \\sum_{i=1}^N (x_i - \\mu)^2 \\over N}\n\\]\nThe standard deviation gives the uncertainty in a single measurement. If the experiment were repeated again, under identical conditions, the standard deviation would be the uncertainty associated with any single measurement. Just as with the mean, the standard deviation becomes more reliable (smaller uncertainty) as the size of the data set increases.\nWhere did this expression for the standard deviation come from? A full derivation won’t be shown here (see me if you’d like more information), but some brief motivation for why this expression is a measure of the spread in the data will be given. First notice the quantity \\(x_i - \\mu\\), which is a measure of how far away each data point is from the mean. Summing up these differences would be some indication to the amount of spread in the data. However, since some of these differences will be positive and some negative, summing them could result in zero even when the spread in the data is not zero. Instead the square of the differences is summed: \\(\\sum_{i=1}^N (x_i - \\mu)^2\\) and then divided by \\(N\\) to get an average.\n\\[\n{1\\over N} \\sum_{i=1}^N (x_i - \\mu)^2\n\\]\nThe final expression is the square root of this expression:\n\\[\n\\sigma = \\sqrt{{1\\over N} \\sum_{i=1}^N (x_i - \\mu)^2}\n\\]\n\n\nStandard Deviation of the Mean\nNotice that the standard deviation was not assigned to be the uncertainty in the mean. The reasoning for this is subtle. The shape of the histogram improves with each data point added and therefore the uncertainty associated with the mean should decrease also. However, the standard deviation does not decrease as \\(N\\) increases. Even though \\(N\\) is on the denominator of the expression, as \\(N\\) increases so too does the numerator. Hence, both the numerator and denominator increase together.\nThe uncertainty in the mean is given by\n\\[\n\\sigma_N = {\\sigma \\over \\sqrt{N}}\n\\]\nwhich decreases as more data points are added. This is the quantity that we should assign to be the uncertainty of the mean.\n\n\nComparing Results\nIn lab #1, the success of an experiment was decided by comparing the fractional uncertainty to the percent error. If the fractional uncertainty was bigger than the percent error then the experiment was judged to be a success. While this criteria isn’t wrong, it doesn’t tell us how good or bad the agreement is and it also doesn’t provide any boundary between acceptable and unacceptable results. We are now in a position to describe a more robust criteria for judging success.\nRecall that every time an experiment is performed the measurements gathered are random draws from a distribution. This distribution is assumed to be centered at the expected value (\\(x_e\\)). If the results of the experiment (usually the mean) are too far away from the expected mean, the probability that the measurements were random draws from the assumed distribution is so small that we lose confidence in that assumption. The figure below illustrates this idea. The red curve is the assumed distribution centered at the expected value and the blue bars indicate the measurements during the experiment. The mean of these results is indicated by the red dashed curve and the expected mean is indicated by the green dashed curve.\n\n\n\n\n\nTo determine the probability that these data points came from the assumed distribution we first calculate the quantity\n\\[ t = {|x_b - x_e|\\over \\sigma_n}\\]\nwhich measures how many standard deviations of the mean the measured result differs from the expected result. Here \\(x_b\\) is the best result from your experiment(usually the mean of your dataset), \\(x_e\\) is the expected value, and \\(\\sigma_n\\) is the standard deviation of the mean.\nFor values of \\(t &lt;1\\) the experiment is probably a success and for \\(t \\gg 1\\) the experiment probably isn’t a success. But what about intermediate values? It would be nice to make a more probabilistic statement about the success of our experiment. Something like, “The probability that the results of our experiment were drawn from a distribution with the expected result as the mean is 90%”\nWe can use Python to answer this question using the code given below.\n\nfrom scipy.stats import ttest_1samp\nresults = [1.64,1.57,1.72,1.55,1.68,1.62,1.70,1.59]\n\nexpected_value = 1.67\nP = ttest_1samp(results,expected_value)\n\nprint(P.pvalue)\n\n0.14392654580468714\n\n\nThe result is called a p-value and in this case it is equal to \\(0.144\\) or \\(14.4\\%\\). This means that the probability that \\(x_b\\) was a random draw from the assumed distribution(centered at \\(x_e\\)) is \\(14.4\\%\\)\nThe boundary between acceptable and unacceptable depends on the level below which we judge a discrepancy to be unreasonably probable. This really is a matter of opinion but often a community of people will agree on a certain level. Many scientists regard \\(5\\%\\) to be the appropriate boundary and if the p-value is smaller than \\(5\\%\\) the discrepancy is deemed significant. In other words, the probability of obtaining the result as a random draw from a distribution centered at the expected value is so small that it probably didn’t. In this case, the scientist ought to look for mistakes in the experimental setup.\nOn the other hand, if the p-value is above the boundary, the discrepancy is deemed insignificant and the experiment is deemed a success. Note that p-values do not confirm the hypothesis, but just fail to reject it.\nA p-value for two data sets can be calculated to see if their distributions are statistically the same. As before the relevant quantity is\n\\[ t = {|x_b - x_e|\\over \\sigma_\\text{joint}}\\]\nbut the standard deviation is now given by\n\\[\\sigma_\\text{joint} = \\sqrt{{N_1 + N_2\\over N_1 N_2} \\cdot {(N_1 - 1)\\sigma_1^2 + (N_2 - 1)\\sigma_2^2 \\over N_1 + N_2-2}}\\]\nFortunately, python can do all of these calculations for us. For example, if two groups of students measure the time it takes for a ball to fall \\(3.00\\) m, you could use the code below to calculate a p-value.\n\nfrom scipy.stats import ttest_ind\ndataOne = [0.75,0.74,0.79,0.76,0.77,0.73,0.74,0.78,0.76,0.75]\ndataTwo = [0.81,0.80,0.79,0.76,0.77,0.80]\n\nP = ttest_ind(dataOne,dataTwo)\n\nprint(f\"The p-value for these two data sets is {P.pvalue:8.4f} = {P.pvalue*100:4.2f} %.\")\n\nThe p-value for these two data sets is   0.0067 = 0.67 %.\n\n\nSince the p-value is less than the \\(5\\%\\) boundary we conclude that the results from these two experiments differ significantly."
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#python-skills",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#python-skills",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Python Skills",
    "text": "Python Skills\n\nPlotting Histograms\nTo plot a histogram in Python you should use the pyplot.hist(data) function and pass your data set into the function. There are several optional arguments to the hist function that can help customize the appearance. A few of the more important ones are given in the table below\n\n\n\n\n\n\n\n\nOptional Argument\nDescription\nExample\n\n\n\n\nbins\nSpecify how many bins should be displayed.\nbins = 20\n\n\ncolor\nSpecify what color the bars should be.\ncolor = “blue”\n\n\nedgecolor\nSpecify the color of the edge of the bars.\nedgecolor = “red”\n\n\n\nSome example code for building a histogram is given below.\n\nimport matplotlib.pyplot as plt\nimport numpy.random as rand\n\ndata = rand.normal(5,.5,1000) # Dummy data just for this example.\n\nax = plt.axes()\nax.hist(data,bins = 20,color = 'blue',edgecolor = 'black')\nplt.show()\n\n\n\n\n\n\nPlotting functions\nPlotting a function in Python can be accomplished by following these steps:\n\nBuild a list of x value (horizontal axis).\nCalculate the function value for every x value.\nUse pyplot.plot(x,y) to plot the x-y pairs.\nUse pyplot.show() to display the plot.\n\nSeveral options to the pyplot.plot() function will allow you to customize the plot. Some common ones are listed below:\n\nlinestyle: specify what the line representing the function looks like.\ncolor: Specify the color of the line representing the function.\nlinewidth: Specify the thickness of the line representing the function.\n\nThe functions ax.set_xlabel(), ax.set_ylabel(), and ax.set_title() can also be used to specify axes labels and a plot title. An example is given in the code cell below.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0,2 * np.pi,0.1) # Step 1\ny = np.sin(x)                  # Step 2\nax = plt.axes()\nax.plot(x,y,linewidth = 4,color = 'black',linestyle = \"--\")  # Step 3\nax.set_xlabel(\"x\")\nax.set_ylabel(\"f(x)\")\nax.set_title(\"f vs x\")\nplt.show()                     # Step 4\n\n\n\n\n\n\nReading Data Files\nIn this lab we will be reading in a CSV file, which is a file where a comma is used to separate the numbers. The function np.genfromtxt() will read a file like this and put it into a numpy array for later use. The genfromtxt function requires only one argument (the file name) with another optional argument (delimiter) that is typically included to specify the character used to separate the data. Below is an example to read a hypothetical file named squares.csv file (comma separated values).\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nprint(data)\n\nNotice that the data was read into a NumPy array (2D in this case because there were two columns of data), which means that we can easily slice off the individual columns if needed.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nnumbers = data[:,0]\nsquares = data[:,1]\n\nOther optional arguments that can be used with the genfromtxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nThe string used to separate value. By default, whitespace acts as the delimiter.\n\n\nskip_header\nThe number of lines to skip at the beginning of a file.\n\n\nskip_footer\nThe number of lines to skip at the end of a file.\n\n\nusecols\nSpecify which columns to read with 0 being the first. For example, usecols = (0,2,5) will read the 1st, 3rd, and 6th columns.\n\n\ncomments\nThe character used to indicate the start of a comment. Lines beginning with this character will be discarded.\n\n\n\nImportant: If the file you are reading is not located in the same directory as this jupyter notebook, genfromtxt will not be able to find the file. In this case, you have two options: 1- copy the file from its current location into the directory where this jupyter notebook is located, or 2- Use python’s os module to change your working directory to where the file is located.\nIf you choose the second option you’ll need to familiarize yourself with the os module, which can perform standard operations on the files and folders on your computer. When opening files from a python script, the default search path is the directory where the current file is located. If you want to open files located in other directories, you may need to use the os module to navigate there first. The following functions are the most commonly used ones\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ngetcwd()\nShort for get current working directory. Returns a string of the current directory.\n\n\nchdir(path)\nChange the current working direction to be at path.\n\n\nlistdir()\nList all of the files and folders in the current working directory.\n\n\nmkdir(path)\nMake an new directory at location path.\n\n\n\nIn the cell below, we show the usage of these functions.\n\nfrom os import getcwd,chdir,listdir\n\ncurrentdir = getcwd()  \nmyfiles = listdir()\nprint(currentdir)\nprint(myfiles)\n#chdir(/path/to/new/directory)"
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-i-pendulum-period-33-points",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-i-pendulum-period-33-points",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Activity I Pendulum Period (33 points)",
    "text": "Activity I Pendulum Period (33 points)\n\nEquipment needed\n\n1.5-meter-long pendulum.\nStopwatch (the one on your phone will do)\n\n\n\nGoal (Overview)\nEach student will measure the period of a 1.5-meter-long pendulum 10 times. This will result in a set of ~150 data points for the whole class. We will then calculate the acceleration due to gravity for each measurement and calculate the i) mean, ii) standard deviation, and iii) standard deviation of the mean and use these results to report an appropriate uncertainty.\n\n\nProcedure\n\nA pendulum that is 1.5 meters long will be set up at the front of the class. Each person should measure the period of the pendulum with a stopwatch 10 times. Data should be recorded to the nearest 0.01 s. For the best results try to keep the pendulum’s amplitude consistent for all of the measurements, even by restarting as necessary. The amplitude should be relatively small (less than about \\(10^\\circ\\)). The pendulum should be swinging (rather than at rest) when the time measurement begins.\nRecord your 10 measurements in the google sheets link provided below.\nOnce everyone has collected their measurements someone needs to move all of the data into a single column. Then download the file to your computer, saving it as a .csv file. Then use the np.loadtxt() function to read this data into Python. Do this on line 7 of the code cell below. (Remember: The file must be located in the same directory as this Jupyter notebook.)\nThe acceleration due to gravity can be calculated from \\[ g = {4 \\pi^2 L \\over T^2}\\] On line 9 of the code cell below calculate the acceleration due to gravity for each period measurement in the data set. To include \\(\\pi\\) in your calculation use np.pi.\nUse the equations given in the reading above to calculate the mean, standard deviation, and standard deviation of the mean. Perform these calculations on lines 10, 11, and 12 of the code cell below. Use np.sum() to perform summations and np.sqrt() to perform square root functions.\nOn lines 14,15, and 16 in the code cell below use the functions stats.mean() and stats.stdev() to calculate the mean, standard deviation, and standard deviation of the mean.\n\nConstruct a dataframe of data with the period located in the first column and the values of g in the second column.\nA statistical analysis of the data can be generated using dataframe.describe(), which creates a new dataframe containing often used statistics. Do this on line.\n\nAdd a formatted print statement to report an appropriate value for \\(g\\) with its uncertainty.\nPlot a histogram of the g values.\n\nThe normal distribution is given by \\[ N(x) = {1\\over \\sigma \\sqrt{2 \\pi}} e^{-(x- \\mu)^2\\over 2 \\sigma^2}\\]. Plot this distribution on top of the histogram. Verify that the limiting distribution matches the histogram.\n\nCalculate the p-value for this dataset using \\(g= 9.8\\) as the expected value. State whether the deviation of your experimental results are significant enough (at the \\(5\\%\\) level ) to reject the experiment. Do this on line 22 in the code cell below.\n\nPendulum Data\n\nimport numpy as np\nimport statistics as stats\nimport math as mt\nfrom scipy.stats import ttest_1samp\n\n%matplotlib inline\n\nT =   # Line 7\nN = len(T)     # Find the number of data points.\ng =            # Line 9\nmeanG =        # Line 10\nstdG =         # Line 11\nstdMeanG =     # Line 12\n\nμ =            # Line 14 \nσ =            # Line 15\nσ_μ =          # Line 16\n\ndf =  # Construct a dataframe with periods in the first column and g-values in the second. (Line 18)\ndisplay(df)\nsummary =  #Construct a summary dataframe containing often-used statistics (Line 20)\ndisplay(summary)\np_value =      # Line 22\n\n\n\n# Plot the histogram and Normal distribution below."
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-ii---radioactivity-33-points",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-ii---radioactivity-33-points",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Activity II - Radioactivity (33 points)",
    "text": "Activity II - Radioactivity (33 points)\n\nEquipment needed\n\nGeiger Counter\nRadioactive sample (don’t worry, they aren’t active enough to be dangerous)\nLabQuest mini box with USB cable.\nLogger Pro software. You can download a copy for your personal machine (windows or mac ) or use one of the lab computers which have Logger Pro installed already.\n\n\n\nGoal (Overview)\nWe will use the electronic radiation monitor to measure the number of decays for a radiocative sample. We will calculate the mean and standard deviation of the data and make a histogram of the data. The Poisson distribution will be plotted on top of the histogram to show it as the limiting distribution.\n\n\nProcedure\n\nUsing the Vernier Radiation Monitor, measure the decays of a radioactive sample. Below you will find the instructions for setting up the Vernier Radiation Monitor to your laptop. Use 10-second intervals and make 100 measurements.\n\nCopy the data from Logger Pro to an Excel spreadsheet and save the worksheet.(The worksheet should have only one column of data. Don’t include the time data in the Excel worksheet.)\nUse the equation above for the mean (\\(\\mu\\)) to calculate the mean of the data and the equation below to calculate the standard deviation of the data. \\[\\sigma = \\sqrt{\\mu}\\]. Perform these calculations on lines 7 and 8 in the code cell below.\nAdd a formatted print statement to report the appropriate count number with its associated uncertainty.\nOne line 11 of the code cell below, produce a histogram just as we did together in activity I. Choose bins = so that the histogram displays a sufficient amount of detail.\nThe limiting distribution for this kind of data is called a Poisson distribution (equation given below). It is only defined for integer values of the argument and it is hard to plot using standard plotting techniques. I have provided the code to plot this function in the code cell below. You may have to modify the numbers on line 14 to plot over the appropriate range. \\[P(x) = e^{-\\mu} {\\mu^x \\over x!} \\]\n\n\nInstructions for using the Vernier Radiation Monitor:\n\n\n\nConnect the Vernier Radiation Monitor to the DIG 1 port of the LabQuest Mini.\nConnect the USB cord from the LabQuest Mini to your laptop.\nWithin the LoggerPro software, do the following:\nSelect Experiment -&gt; Data Collection and change the duration to 1000 seconds.\n\n\n\n\nfrom scipy.stats import poisson,norm\nfrom numpy import arange\nfrom matplotlib import pyplot as plt\n\ndata =  #Load the data from file (Line 5)\n\nμ =   # Calculate mean (Line 7)\nσ =   # Calculate standard deviation (Line 8)\n\n              \n              # Construct Histogram (Line 11)\n\ndist = poisson(μ)\nx = arange(0,40)    # Line 14: May have to modify these numbers.\nax.plot(x,dist.pmf(x))\nplt.show()"
  },
  {
    "objectID": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-iii---projectile-range-33-points",
    "href": "labs/Lab4-Statistical-Uncertainty/L4-Statistical-Description-Uncertainty.html#activity-iii---projectile-range-33-points",
    "title": "Lab 4: Statistical Interpretation of Uncertainty",
    "section": "Activity III - Projectile Range (33 points)",
    "text": "Activity III - Projectile Range (33 points)\n\nGoal (Overview)\nThis activity is identical in nature to Activity I. Instead of measuring the period of a pendulum, we will measure the range of a projectile. The analysis of the data will be very similar to that performed in Activity I.\n\n\nSetup\n\nAs a class, pick some launch conditions. These must include the launch angle, launch power setting, and initial height.\nAs a group, use your code from Activity I from lab 3 to calculate the exit speed of the ball.\nWrite the launch conditions (initial height, launch angle, and exit speed) on the board at the front of the class.\nSetup the cannon in a location where everyone in the class can access it and perform measurements.\n\n\n\nProcedure\n\nUsing the launch conditions chosen in step 1, predict the range of the steel ball. Perform the calculations in the code cell below.\nUsing the projectile launcher, fire a steel ball 10 times per student and measure the range in meters.\n\nAgain, we will pool our data together as a class to increase the size of the dataset. Therefore, it is very important that every student launches under the same conditions and every students’ measurements are free of bias. Add your data to the Google sheets document linked below.\nWhen all the data is collected, have Python read the data set using np.genfromtxt() just as you did in activity I.\nCalculate the mean, standard deviation, and standard deviation of the mean using your preferred calculation method. (Either with stats.mean() and stats.stdev() ,using the equations given above, or using a python dataframe.)\nPlot a histogram of the data. Choose bins = appropriately so the histogram displays with sufficient detail.\nPlot the normal distribution on top to verify that it is the limiting distribution.\nAdd a formatted print statement to report the particle’s range with its associated uncertainty.\nCalculate the p-value for your data set using the predicted range from part 1 as your expected value. State whether the deviation of your experimental results are significant enough (at the \\(5\\%\\) level ) to reject the experiment.\n\nNo template code cell will be provided for this activity (hopefully you are feeling more and more comfortable writing simple code on your own), but you can copy/paste from previous activities if needed.\nProjectile Data\n\n# Put code here"
  },
  {
    "objectID": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#skills",
    "href": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#skills",
    "title": "Lab 5: Experimental Design I",
    "section": "Skills",
    "text": "Skills\n\nLearn how to fit a curve to some data.\nLearn how to extract physical meaning from the fit parameters.\nPerform interpolation and extrapolation calculations.\nLearn how to plan and carry out a high-quality scientific experiment.\nLearn the appropriate way to record your work during a scientific experiment."
  },
  {
    "objectID": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#background-information",
    "href": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#background-information",
    "title": "Lab 5: Experimental Design I",
    "section": "Background Information",
    "text": "Background Information\n\nPython Skills\n\nCurve Fitting\nOften in science you will gather data as a way to explore the relationship between two physical quantities and/or to validate your theories. For example, consider the time it takes a car to stop, starting from the moment you slam on your brakes(locking them in place and skidding to a halt). The question is: How does the stopping time depend on the car’s initial speed. If you are familiar with Newtonian mechanics at all, you might hypothesize that the acceleration of the car should not depend on the initial velocity and hence the stopping time will increase linearly with the initial speed. Furthermore, the following kinematic equation\n\\[\n\\begin{align*}\nv_f &= v_i - a \\Delta t\\\\\n0 &= v_i - \\mu_k g \\Delta t\\\\\n\\Delta t &= {v_i\\over \\mu_k g}\n\\end{align*}\n\\] would suggest that the slope of \\(\\Delta t\\) vs. \\(v_i\\) function is \\({1\\over a} = {1\\over \\mu g}\\). In other words, the theory of kinematics suggest that the acceleration should be independent of initial speed. To prove your idea, you should first measure the stopping time for cars with a variety of initial speeds (shown below).\n\n\n\nInitial Speed (m/s)\nSkid time (s)\n\n\n\n\n12\n3.23\n\n\n17\n3.43\n\n\n22\n4.67\n\n\n25\n5.45\n\n\n29\n6.00\n\n\n38\n8.52\n\n\n\n\n\nText(0.5, 1.0, 'Skid time vs initial speed')\n\n\n\n\n\nWe notice that the data looks linear which matches our hypothesis that the acceleration is constant.\nThe next thing to do is to find the line that passes through the data points as close as possible. When the fit function is a polynomial , we can use the polyfit function from numpy. This function takes three argument: the independent data set, the dependent data set, and the order of the polynomial\npolyfit(x,y,order)\nThe polyfit function returns a list of numbers containing the function parameters for the best fit function.\n\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nslope = params[0]\nyint = params[1]\n\ng=9.8 #Acceleration due to gravity\nmu = 1/(slope * g)\nprint(params)\nprint(mu)\n\n[0.20971747 0.21840032]\n0.48656326406696404\n\n\nIn this case, \\(0.2097\\) is the slope of the best-fit function and \\(0.2184\\) is the y-intercept of the best fit function. Remembering our theory from above, we notice that the slope of this fit function can be used to calculate the coefficient of friction between the rubber tires and the roadway. \\[\n\\begin{align*}\nm &= {1\\over \\mu g}\\\\\n\\mu &= {1\\over m g}\n\\end{align*}\n\\] It is often useful to plot the fit function on top of the data to verify that it really matches the data.\n\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit,linspace\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nvDense = linspace(8,40,100)\ntDense = params[0] * vDense + params[1]\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDense,'k',lw = 3)\nplt.xlabel(\"Initial Speed(m/s)\")\nplt.ylabel(\"elapsed time to stop (s)\")\nplt.title(\"Skid time vs initial speed\")\n\nText(0.5, 1.0, 'Skid time vs initial speed')\n\n\n\n\n\nThe uncertainty in the fit parameters can be determined by polyfit by adding the optional argument cov=True when you call it. This causes the polyfit function to return two things: 1- a list of parameter values (the slope and y-intercept for our case) and 2- a matrix of covariance values, the diagonal value of which are the standard deviations squared. Let’s see how we could access these numbers and display them.\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = np.polyfit(vi,t,1,cov = True)\nslope = params[0][0]\ndslope = np.sqrt(params[1][0][0])\nyint = params[0][1]\ndyint = np.sqrt(params[1][1][1])\n\nprint(f\"The slope is {slope:5.2f} +- {dslope:2.2f}\")\nprint(f\"The y-int is {yint:5.2f} +- {dyint:2.2f}\")\n\nThe slope is  0.21 +- 0.02\nThe y-int is  0.22 +- 0.48\n\n\n\n\nLinearizing Equations\nThe data above was linear, just like our hypothesis suggested, but this won’t be the case for many realistic data sets. One “tool” that a scientist frequently uses to investigate possible relationship is to attempt to linearize the data using a hypothesis. As an example, consider dropping a ball from rest, and measuring how far it has fallen at regular time intervals. Kinematics tells us that the relationship between \\(y\\) (the distance fallen) and \\(t\\) (the time elapsed) is: \\[y = {1\\over 2} g t^2\\] where \\(g\\) is the acceleration due to gravity. This equation represents our hypothesis, which means that we don’t expect the relationship between \\(y\\) and \\(t\\) to be linear. The plot of \\(y\\) vs. \\(t\\) looks like this:\n\n\n\n\n\nThat is definitely not a linear relationship. But the data can be manipulated to become linear by following these steps:\n\nFirst isolate the dependent variable, or the thing you measured, on the left hand side of the equation. In this case, that would be our distance fallen, \\(y\\).\nIf the expression on the right hand side takes the form of a line (\\(mx + b\\)), the relationship is linear. If it isn’t, analyze the expression and define a new independent variable that will make the equation look linear. In this case, we should choose the independent variable to be \\(t^2\\) rather than \\(t\\). Making this changes means that \\({1\\over 2} a\\) becomes the slope of the new slope and \\(0\\) is the y-intercept. If our hypothesis is correct, a plot of \\(t^2\\) vs \\(y\\) should appear linear:\n\n\n\n\n\n\nand indeed it does.\n\n\n\nDesigning an Experiment\nOne of the objectives of this course is to learn how to design and carry out a successful experiment. In grade-school an experiment was any science related activity (the proverbial building of a volcano model was considered an experiment), but for a scientist an experiment is used to test a hypothesis. This test must be carried out carefully because the entire foundation of science depends on the integrity of the process. In today’s lab, we’ll be working with a mass attached to a spring and allowed to oscillate up and down.\nFrom your introductory phyiscs class you may remember Hooke’s law \\(F = -k \\Delta x\\) which gives the force of the spring on the mass. Another result from introductory physics involves the relationship between the period the motion (\\(T\\)) and the mass (\\(m\\)) \\[T = C\\sqrt{m}\\] where \\(C = \\sqrt{4 \\pi^2 \\over k}\\). In other words \\(T \\propto \\sqrt{m}\\). This will be the hypothesis that we want to test in today’s lab.\n\n\n\nThe steps for planning and conducting a scientific experiment are found below. When conducting an experiment, always follow these steps to ensure success.\n\nIdentify the system to be examined and list all of the inputs. In our case it is a mass-spring system, which involves a mass(\\(m\\)) and a spring, whose stiffness is characterized by a spring constant (\\(k\\)). The forces acting on the mass are (i) gravity and (ii) the tension in the spring. These are the inputs. They are the quantities that could change in the design of your experiment. The first step in designing your experiment is to give a short description of the system in a lab notebook (or jupyter notebook in our case).\nIdentify the model to be tested. The word “model” means a mental picture of how something works. Physicists prefer to express a model as a mathematical equation. For example, there is a model for how force depends on acceleration. The greater the net force, the bigger the acceleration of the object. The mass also fits into the model: The larger the mass, the larger the force needed to create the same acceleration. This mental model can be expressed in an equation \\(F = ma\\).\nIt is valuable to use both the word description of the model as well as a mathematical representation. Today, the mental model is that the period of oscillation for a mass-spring system depends directly on the square root of the mass. Think about what this means. If I increase the mass, the period should get longer. But if I double the mass, the period won’t double. This is a mental model that allows us to do predictions of behavior. In physics it is almost required to reduce this model to an algebraic equation that can be used to calculate a prediction and an uncertainty on that prediction. For today’s experiment that equation is \\[T = C\\sqrt{m}\\] where C is a factor that does not depend on mass. Today, this equation is given to you but for future experiments your group will have to come up with their own mathematical expression of the model. In your lab notebook (jupyter), record your model and the model equation.\nPlan how you will know if the experiment is successful. The success of your experiment is more likely if you anticipate (or plan) what that success will look like. One way to do this is to plan how you will communicate your results. Often these results will take the form of a graph or plot of some kind and you should think of what graph you will make at the end of the experiment to communicate whether your model works (or not). In today’s experiment, a graph of T vs. m or even T vs.\\(\\sqrt{m}\\) might be useful along with a curve fit. Thinking about how you will communicate your results helps you decide what measurement you will make. In our case today it is hard to plot T vs. m if you don’t measure T and m, and recognizing this in advance helps you plan the experiment. Mock up your graph or figure in your lab notebook. Give axis titles and even units (but of course no data yet).\nPlan your analysis.\n\nSymbolically layout and solve any needed equations (including the uncertainty equations) so that you will know exactly what measurements you need to make.\nPlan how you will linearize your equation from step 3. The data from today’s lab can be linearized by either (i)- taking the square root of the mass values, or (ii)- squaring the period values.\n\nPlan how you will fit a curve to your data. The strongest and most reliable curve fits are straight line fits so you should plan on fitting to linearized data if possible. If the equation can’t be linearized, it should at least be rendered into a form that can be used to predict the outcome of the experiment. Record your new equation in your lab notebook.\nOften the parameters in your fit can be used to calculate physical quantities associated with your experiment. You should calculate these values and compare to their true values as further evidence that your hypothesis is correct. Plan how you will use the parameters of your fit to calculate some physical property of the system. In today’s lab \\[ T = \\sqrt{4 \\pi^2 \\over k} \\sqrt{m}\\], which means that if you fit to \\(T\\) vs \\(\\sqrt{m}\\) data, the slope of that fit will be equal to \\(\\sqrt{4 \\pi^2 \\over k}\\). This equation can then be solved for the spring constant (physical property) as: \\(k = {4\\pi^2\\over\\text{slope}^2}\\)\nPlan how you will use the fit function to predict between experimental data point (interpolation) or beyond the last data point (extrapolation). Predicting the result of an experiment that hasn’t been performed yet and then verifying that the experimental results match is a great way to build even more confidence in your hypothesis. Plan this process out mathematically and experimentally at this step.\n\nChoose ranges for the pertinent experiment variables. For today’s experiment the variables of interest are \\(m\\) and \\(k\\) and you should think carefully about reasonable values. It should be clear when you see the spring that putting a thousand kilograms of mass on the spring would be a bad idea. What values of \\(m\\) will give you good results in testing your theory and what values will not? Using uncertainty analysis on the equation can be helpful in making this decision too; changes in mass that produce a change in T that is smaller than its uncertainty will not be noticeable and are a waste of time. Changes that are likely to break the equipment are also not desirable. All of these considerations should be considered before the experiment is conducted. If you fail to do this you may find find that you did not get good data, and must repeat all your work! Record your variable ranges in your lab notebook. As you perform the experiment note any deviations from this plan.\nPlan the experimental procedure. The group should talk their way through the experiment. You might find yourselves saying something like “then you take the stopwatch and measure the period..” and you realize that you did not get a stop watch. Determine whether the equipment you need is available. Get in the habit of working through the procedure in advance to see if anything has been forgotten. Record the planned procedure in your lab notebook. As you perform the experiment, note any deviations from the plan and the reason for the deviation. Deviations are fine, just make sure you record them.\nPerform the experiment and report on it in your lab notebook (jupyter). All of the previous steps were just planning. In this step you should actually do what you have planned to do. Then report your results. Specifically, in this step you should….\n\nExplain the procedure that was actually followed, recording what you really did as you do it. This will probably not be just a restatement of the plan because things will change as you go. Record the equipment used and settings, values, etc. for that equipment. Did you learn how to use any new equipment? What did you learn that you want to recall later (say, when taking the final, or when you are a professional and need to use a similar piece of equipment five years from now).\nRecord the data you used. If you have a large set of values, you can place them in a file, and then record the file name and location in your lab notebook. Make sure this is a file location that does not change (emailing the data to yourself is still not a good plan).\nGive a record of the analysis you performed. You planned this above, now record what you actually did\nGive a brief statement of your results and their associated uncertainties.\nDraw conclusions: Do your results support the theory? Why or why not? What else did you learn along the way that you want to record. (This is where we may compare the percent error to our relative uncertainty)."
  },
  {
    "objectID": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#activity-i--conduct-the-expriment-mass-spring-system",
    "href": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#activity-i--conduct-the-expriment-mass-spring-system",
    "title": "Lab 5: Experimental Design I",
    "section": "Activity I- Conduct the expriment (mass-spring system)",
    "text": "Activity I- Conduct the expriment (mass-spring system)\nFollow all of the steps outlined above to perform a high-quality experiment involving a mass-spring system. Since this is your first time, an outline of the steps will be provided below.\n\nIdentify the system being studied. List all relevant variables.\n\n\nYour response:\n\n\nIdentify the hypothesis or model that you will test. Provide both a verbal description of this model and and mathematical equation. (use \\(\\LaTeX\\))\n\n\nYour response:\n\n\nHow will you know if your experiment is successful?\n\n\nYour response:\n\n\nPlan your analysis. Address all five questions mentioned above.\n\n\nYour response:\n\n\nChoose reasonable ranges for the pertinent variables in your experiment.\n\n\nYour response:\n\n\nPlan the experimental procedure.\n\n\nYour response:\n\n\nCarry out the experiment and report your results. Include all data collected, plots constructed and give evidence for or against your hypothesis. Data should be placed in a table of some kind. You can either use a markdown table in a text cell or a Pandas dataframe to display the data. Make sure you accomplish everything mentioned in step 4 above.\n\n\nYour response:\n\n\n# Perform calculations and construct plots here."
  },
  {
    "objectID": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#activtity-ii---interpolation-and-extrapolation-testing-the-law",
    "href": "labs/Lab5-Experimental-Design-I/L5-Experimental-Design-I.html#activtity-ii---interpolation-and-extrapolation-testing-the-law",
    "title": "Lab 5: Experimental Design I",
    "section": "Activtity II - Interpolation and Extrapolation (Testing the Law)",
    "text": "Activtity II - Interpolation and Extrapolation (Testing the Law)\nTest the law you developed in activity I. Use the equation for the period to predict periods for masses that you haven’t tried. Then measure the periods to verify that the prediction was correct. Do this in two way:\n\nBy interpolating, predict the period of oscillation for an \\(80\\) g mass. Record your methods and results. Interpolation means to predict an output value (in this case, a period) for an input value that falls within the range of the input values you have used in your measurements. If you measured periods for \\(20\\) g, \\(30\\) g, \\(40\\) g, \\(50\\) g, and \\(100\\) g, then \\(80\\) g is within this range. Using the curve fit equation generated by the data we measured, we can plug in \\(80\\) g and predict the period for our spring with an \\(80\\) g mass. This is interpolation. This will test our model to see if it works for new inputs. If it does not, our model is probably not good.\n\nBy extrapolating, predict the period of oscillation for a \\(300\\) g mass. Record your methods and results. Extrapolation means to predict an output value (in this case, a period) for an input value that falls outside the range of the input values you have previously measured. If you measured periods for \\(20\\) g, \\(30\\) g, \\(40\\) g, \\(50\\) g, and \\(100\\) g, then \\(300\\) g is outside this range. Using the curve fit equation generated by the data we measured, we can input \\(300\\) g and predict the period for our spring with an \\(300\\) g mass. Extrapolation is more risky. The conditions of our experiment might change outside our range (think, in a limiting case, we could break the spring, and get an infinite period!). But if things are done carefully, this is also a test of the validity of our model.\n\n::: {.cell execution_count=9} {.python .cell-code}    # Perform calculations here :::"
  },
  {
    "objectID": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#skills",
    "href": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#skills",
    "title": "Lab 6 Experimental Design II",
    "section": "Skills",
    "text": "Skills\n\nGet more experience designing and executing a scientific experiment.\nLearn the appropriate structure, style, and content of a scientific proposal."
  },
  {
    "objectID": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#background-information",
    "href": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#background-information",
    "title": "Lab 6 Experimental Design II",
    "section": "Background Information",
    "text": "Background Information\n\nStanding Waves\nStanding waves result from making waves that reflect back on themselves, or by making waves on both ends of a string. When we were children we formed a type of standing wave with jump ropes.\n\n\n\nThis standing wave had a part that went up and down in the middle and two parts that did not move much on each end (called nodes). But if you had a bored kid, you might have seen a standing wave that looks like this.\n\n\n\nThis is not so good for jumping, but makes an interesting picture. The part in the middle that does not seem to be moving is called a node. Really there are also nodes on each end of the rope as well. So altogether there are three nodes in this picture. We can make standing waves that have many nodes. If you try this with a jump rope, you will find that the more nodes you have, the faster you have to shake your end of the rope. Another way to say this is that the frequency of your wave you are making must increase with the number of nodes. This is part of today’s model. In the setup on your table, ring stands are holding strings, and there is an oscillator on one end that has a frequency control box. The other end has a pulley and a hanging mass to provide tension on the string.\n\n\n\nExperimentally we find that not all frequencies will make standing waves. So our model includes the idea that only some frequencies produce standing waves. Our model also includes the idea that the weight of the string will change which frequency will make a standing wave. If you play a stringed instrument, you may have noticed that some strings are thicker than others. Thicker strings have different standing wave frequencies than thinner strings. If you study this model (some of you will in PH123), you can derive an equation that tells which frequencies will work \\[f={n\\over 2L} \\sqrt{ Mg\\over \\mu}\\] where n is an integer (\\(n = 1, 2, 3 \\dots\\)). This integer for strings is the number of nodes minus one \\(n = n_\\text{nodes} − 1\\). So you can form a standing wave, then count the places that don’t seem to move (remember the ends!) and subtract one to find n. The frequency that creates the standing wave should be a function of \\(n\\). Our model tells us that if we know n, we should be able to predict the frequency. You will find that for each way you can make a standing wave, a small range of frequencies will make the standing wave, not just one, single frequency. But the frequency that produces the largest standing wave is the one we want (biggest amplitude–or the one for which the wave looks bigger) . That was the \\(f\\) that was included in forming our model equation. Of course there are other variables in our equation, so we should find out what they are.\nThe quantity \\(\\mu\\) is the linear mass density. It is defined as mass of the string divided by the length of the string. So μ tells us how massive the string is. The quantity \\(L\\) is the length of the string that is participating in the waving, \\(g = 9.8004\\) m/s\\(^2\\) is the acceleration due to gravity, and \\(M\\) is the hanging mass tied to the end of the string beyond the pulley. One way we could verify our model equation is to use it to predict one of the input values. Let’s use \\(\\mu\\). The idea is to use our model equation to somehow find μ and then measure μ to see if the model equation prediction is good.\nLast week we learned that we can take more than one measurement, and use those measurements together with a curve fit to solve for a fit parameter. The quantity \\(\\mu\\) should be in one of the fit parameters. Then you can solve for \\(\\mu\\) using the fit parameter given by your Python linear fit code. This is a more robust way to find \\(\\mu\\), and it is the way I want you to proceed.\nYou may have to adjust the amplitude knob on the frequency controller for some frequencies to keep the apparatus from shaking itself apart. The frequency controller has a fine and a course frequency adjust knob, and a digital frequency display.\n\n\nResearch Proposal\nAt the end of the semester you will be asked to design and carry out a high-quality physics experiment. As part of that process you will submit a research proposal. A proposal is a document that is intended to persuade someone (your professor, funding agency, yourself, etc.) that you should be given the resources and support to perform the experiment. Your proposal should include a short explanation for each of the following topics:\n\nStatement of the experimental problem\n\nWhat hypothesis are you testing?\nWhy is this experiment a noteworthy endeavor?\n\nProcedures and anticipated difficulties\n\nWhat data are you planning to collect?\nHow will this prove/disprove your theory?\n\nProposed analysis and expected results\n\nWhat mathematical analysis will you perform?\n\nPreliminary List of equipment needed\n\nWhat equipment will you need?\n\n\nA short explanation of each element is discussed below.\n\nStatement of the experimental problem\nThis is a physics class, so the experiment should be a physics experiment. The purpose of the experiment is to test a model/hypothesis. This section of the proposal should explain the experimental problem and the model/hypothesis that is being tested.\n\n\nProcedures and anticipated difficulties\nThe first section should be sufficiently intriguing that the reader is encouraged to read on to learn how you will prove that your model is correct. This section of the proposal is all about the experimental setup and the data you plan to collect. Provide some details about how the experiment will be performed and what data you plan to collect. You should also explain in some detail how the experiment will prove or disprove your model. If there are elements of your procedure that will be especially challenging, explain how you plan to get through them. This is essentially steps 1-6 of the experimental design strategy that was introduced last week.\n\n\nProposed analysis and expected results\nIn this section you should describe the plan for analyzing the data and also how you will know if your experiment successfully proves your model (what does success “look like”?). This often involves fitting a function to your data, linearizing the data, and/or plotting the data in a way that proves the expected relationship. Explain in detail which mathematical analysis you chose and justify that choice.\nYou should also discuss the uncertainties that will be present in your experiment and demonstrate that you can achieve an acceptable level of uncertainty with the equipment you are requesting. One theme from this class is that uncertainties in measurements propagate through when used in calculations. In short, uncertainties in calculations can be very different from uncertainties in measurements. When planning an experiment, it is important that you verify beforehand that you can achieve an acceptable level of uncertainty on your final result. This means that you must estimate the uncertainty of your final result and verify that the presumed uncertainties in your measuring devices are sufficiently small. When performing these calculations, it is ok to use order-of-magnitude estimates for measurement values and instrument uncertainties. This analysis will help you make an informed decision about what equipment to use.\nDuring Brother Lines’ career in industry, the US Naval Research Labs once asked his team to build a microwave radiometer to measure the sea wind direction from space. After their predicted analysis, they concluded that they would need a very expensive instrument to be able to successfully measure the wind direction to a reasonable level of uncertainty—it would take more money than they were offering. NRL disagreed with their conclusion and built the device themselves at lower cost, but also to lower specifications with much greater uncertainties. They spent a billion (yes, a billion with a “b” ) dollars to launch the device into space. The device was a total failure because the uncertainty was so big that the data was essentially useless. We want to find out whether our experiment will work before we risk our grades (or a billion dollars) on it. So we will do the prediction ahead of taking the data.\nIn this class we have used sympy to calculate uncertainties. You should use sympy again to calculate the uncertainty that you will need from your equipment to achieve an acceptable level of uncertainty in your final result.\n\n\nPreliminary List of equipment needed\nOnce you have done your analysis, you are ready to list the equipment you will need to carry out your experiment (that is, list the uncertainties you need to achieve). Final approval of the project and the ultimate success of your experiment depends on the equipment you choose or are granted. You want to do a good job analyzing so you know what you need, and a good job describing the experiment so you are likely to have the equipment you want available when you start.\nThe rubric that will be used to grade your proposal can be found here\nAn example proposal can be found here"
  },
  {
    "objectID": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#activity-i-standing-waves",
    "href": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#activity-i-standing-waves",
    "title": "Lab 6 Experimental Design II",
    "section": "Activity I (standing waves)",
    "text": "Activity I (standing waves)\nDesign and carry out an experiment involving standing waves on a string. Record your work below.\n\nIdentify the system being studied. List all relevant variables.\n\n\nYour response:\n\n\nIdentify the hypothesis or model that you will test. Provide both a verbal description of this model and and mathematical equation. (use \\(\\LaTeX\\))\n\n\nYour response:\n\n\nHow will you know if your experiment is successful?\n\n\nYour response:\n\n\nLinearize your equation if possible.\n\n\nYour response:\n\n\nChoose reasonable ranges for the pertinent variables in your experiment.\n\n\nYour response:\n\n\nPlan the experimental procedure.\n\n\nYour response:\n\n\nCarry out the experiment and report your results. Include all data collected, plots constructed and give evidence for or against your hypothesis. Data should be placed in a table of some kind. You can either use a markdown table in a text cell or a Pandas dataframe (see activity I from lab 2 for a refresher) to display the data.\n\n\nYour response:\n\n\n# Perform calculations and construct plots here."
  },
  {
    "objectID": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#activity-ii-proposal",
    "href": "labs/Lab6-Experimental-Design-II/L6-Experimental-Design-II.html#activity-ii-proposal",
    "title": "Lab 6 Experimental Design II",
    "section": "Activity II (Proposal)",
    "text": "Activity II (Proposal)\nWork on your research proposal. They are due in two weeks."
  },
  {
    "objectID": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#skills",
    "href": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#skills",
    "title": "Lab 7 Experimental Design III",
    "section": "Skills",
    "text": "Skills\n\nGet more experience designing and executing a scientific experiment.\nLearn the appropriate structure, style, and content of a scientific report."
  },
  {
    "objectID": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#background-information",
    "href": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#background-information",
    "title": "Lab 7 Experimental Design III",
    "section": "Background Information",
    "text": "Background Information\n\nConservation of Energy\nConseravtion of energy is one of the most fundamental and well-established ideas in physics. It states that the total energy of an isolated system must remain fixed and unchanged as time progresses. If one type of energy decreases, the amount of another type of energy must increase so that the total energy never changes. This week you will design an experiment to prove this hypothesis. You can choose between two experiments: a sphere rolling down an incline or a simple pendulum.\n\nSphere on an Incline\nA sphere that rolls down an incline will gain kinetic energy (both translational and rotational) as it loses gravitational potential energy (because its height is decreasing). Mathematically, this can be stated as\n\n\n\n\\[ U_i = K_f\\] where \\(U_i = M g y\\) is the initial potential energy of the sphere and \\(K_f ={1\\over 2} M v^2 + {1\\over 2} I {v^2\\over r^2}\\) is the total kinetic energy of the sphere at the bottom of the incline. Plugging these in and reducing gives.. \\[M g y = {1\\over 2} M v^2 + {1\\over 2} I {v^2\\over r^2}\\] \\[M g y = {1\\over 2} M v^2 + {1\\over 2} c M r^2 {v^2\\over r^2}\\] \\[M g y = {1\\over 2} M v^2 + {1\\over 2} c M v^2 \\]\n\\[M g y = {1\\over 2} M v^2(1 + c)\\] \\[ y = {v^2\\over 2 g} (1 + c)\\]\nHere \\(c\\) is the constant in the moment of inertial value and should be equal to \\({2 \\over 5}\\) for a sphere. Your goal if you choose this experiment is to design an experiment that proves that this relationship is true and to calculate a value for \\(c\\) with its uncertainty.\n\n\nSimple Pendulum\nThe motion of a pendulum is also a good illustration of the concept of conservation of energy. When the pendulum bobs is at its highest point, it is briefly motionless and hence has no kinetic energy. It only has potential energy. Then, as the pendulum swings downward its potential energy is converted into kinetic energy. In order for energy to be conserved, these two energies should be equal.\n\n\n\n\\[ U_i = K_f\\]\n\\[M g y = {1\\over 2} M v^2\\]\n\\[M g \\left( L - L \\cos \\theta_i\\right) = {1\\over 2} M v^2\\] \\[M g L\\left( 1 - \\cos \\theta_i\\right) = {1\\over 2} M v^2\\]\n\\[ \\left( 1 - \\cos \\theta_i\\right) = {v^2\\over 2 g L} \\] If you choose this experiment, once you have verified the relationship, you should calculate the length of the pendulum with its uncertainty and compare to a measured value.\n\n\n\nScientific Reports\nA scientific report is a detailed description of an experiment that you have performed. The purpose of the report is to add the analysis, results, and conclusions from your work to the collection of knowledge in the scientific community. It is important that your report/experiment invlolves experiments, analysis, and/or results that have not been presented previously. When publishing your report in a scientific journal, the journal will select referees to review your work and ensure that it is Your report should include a short explanation for each of the following topics:\n\nIntroduction\n\nWhat do we already know about the physics of your experiment?\nWhat hypothesis/model are you testing?\nHow will you know if you are successful?\n\nExperimental Setup\n\nWhat did your experiment look like?\nWhat measurements did you perform?\nWhat equipment did you use?\nWhat were the uncertainties in your measurements?\n\nResults and Analysis\n\nWhat data did you gather?\nWhat analysis did you perform?\nHow did you calculate the uncertainty in your final result?\n\nConclusion\n\nDid you prove or disprove your theory.\nWhat are you going to do next?\n\n\nA short explanation of each element is discussed below.\n\nIntroduction\nThe introduction should “hook” your audience, or convince them that your experiment is worth their time and attention. Explain the physics involved in your experiment and state the hypothesis that you are testing. If anyone else in the scientific community has done work in this area, mention them and give them credit with a citation of their work. Make a convincing argument for why this work/experiment is a noteworthy contribution to the scientific community.\n\n\nExperimental Setup\nIn this section you should describe how you setup your experiment. Often, referencing a well-crafted figure can help this discussion greatly. Any figures must have captions with detail sufficient that a reader could understand the figure without reading the main body of the paper. The equipment used in the experiment should be described with their associated precisions (state their uncertainties). Describe how you collected the data and explain any challenges that arose during that process.\n\n\nResults and Analysis\nIn this section you should present your results in a table and/or plot for easy viewing. All plots and tables must have detailed captions and plots must have axes labels and titles that are easily viewable to the reader (without squinting!). If you linearized the data or fit a function to the data, explain how this was done and state your results with uncertainties. Explain how the uncertainty analysis was performed and state all calculated uncertainties. Any math that was performed should be included in this section.\n\n\nConclusion\nExplain why the results of your experiment verified or failed to verify your hypothesis. Describe what the next step in this experiment might be.\nThe rubric that will be used to grade the report for your student-designed project can be found here\nAn example report can be found here"
  },
  {
    "objectID": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#activity-i-conservation-of-energy",
    "href": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#activity-i-conservation-of-energy",
    "title": "Lab 7 Experimental Design III",
    "section": "Activity I (Conservation of Energy)",
    "text": "Activity I (Conservation of Energy)\nDesign and carry out an experiment involving conservation of energy. You can choose an experiment involving a simple pendulum or a sphere rolling down an incline. Your goal is to prove that energy is conserved and calculate any relevant physical quantities with their uncertainties. Record your work below.\n\nIdentify the system being studied. List all relevant variables.\n\n\nYour response:\n\n\nIdentify the hypothesis or model that you will test. Provide both a verbal description of this model and and mathematical equation. (use \\(\\LaTeX\\))\n\n\nYour response:\n\n\nHow will you know if your experiment is successful?\n\n\nYour response:\n\n\nLinearize your equation if possible.\n\n\nYour response:\n\n\nChoose reasonable ranges for the pertinent variables in your experiment.\n\n\nYour response:\n\n\nPlan the experimental procedure.\n\n\nYour response:\n\n\nCarry out the experiment and report your results. Include all data collected, plots constructed and give evidence for or against your hypothesis. Data should be placed in a table of some kind. You can either use a markdown table in a text cell or a Pandas dataframe (see activity I from lab 2 for a refresher) to display the data.\n\n\nYour response:\n\n\n# Perform calculations and construct plots here."
  },
  {
    "objectID": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#activity-ii-student-designed-lab-proposal",
    "href": "labs/Lab7-Experimental-Design-III/L7-Experimental-Design-III.html#activity-ii-student-designed-lab-proposal",
    "title": "Lab 7 Experimental Design III",
    "section": "Activity II (Student-Designed Lab Proposal)",
    "text": "Activity II (Student-Designed Lab Proposal)\nWork on your research proposal. They are due in one week."
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#skills",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#skills",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Skills",
    "text": "Skills\nIn this lab you will gain the following skills\n\nPython\n\nHow to construct a Python for loop.\nLearn the physics of air drag.\nConstruct an Euler’s method code for simple one-dimensional motion."
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#background-information",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#background-information",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Background Information",
    "text": "Background Information\n\nReview of Kinematics\nMost will be familiar with the kinematic equations of motion, which can be used in situations involving constant acceleration. The kinematic equations are. \\[v_f = v_i + a \\Delta t\\] \\[x_f = x_i + v_i \\Delta t + {1\\over 2} a \\Delta t^2\\]\nAs an example, consider a car that is initially at rest, waiting for the stoplight to turn green. Once the light turns green, the driver presses on the accelerator and the car’s speed begins to increase. After accelerating at a rate of \\(a = 5\\) m/s\\(^2\\) for \\(t = 3\\) s, the driver eases up and reduces the acceleration to a more modest \\(a = 2\\) m/s\\(^2\\) and maintains this acceleration for another \\(\\Delta t = 8\\) s. How would you determine the position and speed of the car after the full \\(11\\) seconds had elapsed? The kinematic equations above could be applied to the first 3 seconds of the trip or to the last 8 seconds of the trip, but couldn’t be applied from the start to the end. Let’s use the kinematic equations to determine the speed and position after the first 3 seconds. \\[ v_1 = v_0 + a_0 \\Delta t\\] \\[ = (0 ~\\text{m/s}) + (5 ~\\text{m/s}^2) (3 ~\\text{s})\\] \\[ = 15 ~\\text{m/s}\\] \\[x_1 = x_0 + v_0 \\Delta t + {1\\over 2} a_0 \\Delta t^2\\] \\[ = (0 ~\\text{m}) + (0 ~\\text{m/s}) (3 ~\\text{s}) + {1\\over 2}(5 ~\\text{m/s}^2) (3 ~\\text{s})^2\\] \\[ = 22.5 ~\\text{m}\\] Now that we have the speed and velocity at \\(t = 3\\) we can proceed to use the same kinematic equations for the second part of the motion. \\[ v_2 = v_1 + a_1 \\Delta t\\] \\[ = (15 ~\\text{m/s}) + (2 ~\\text{m/s}^2) (8 ~\\text{s})\\] \\[ = 31 ~\\text{m/s}\\] \\[x_2 = x_1 + v_1 \\Delta t + {1\\over 2} a_1 \\Delta t^2\\] \\[ = (22.5 ~\\text{m}) + (15 ~\\text{m/s}) (8 ~\\text{s}) + {1\\over 2}(2 ~\\text{m/s}^2) (8 ~\\text{s})^2\\] \\[ = 206.5 ~\\text{m}\\] Since the kinematic equations only apply to constant-acceleration motion, the problem had to be divided into two parts: one for each constant-acceleration portion of the motion.\nNow, what if the motion involved 5 different segments, each with a different acceleration, with the acceleration starting at 4 m/s\\(^2\\) and decreasing by \\(1\\) m/s\\(^2\\) every second.\n\n\n\ntime(s)\nacceleration (m/s\\(^2\\))\n\n\n\n\n0\n4\n\n\n1\n3\n\n\n2\n2\n\n\n3\n1\n\n\n\nWe could repeat the process from above to generate the positions and velocities at these four times.\n\n\n\n\n\n\n\n\n\ntime(s)\nx(m)\nv (m/s)\na (m/s\\(^2\\))\n\n\n\n\nequation\n\\(x_{n+1} = x_n + v_n \\Delta t + {1\\over 2}a_n \\Delta t^2\\)\n\\(v_{n+1} = v_n + a_n \\Delta t\\)\n\n\n\n0\n0\n0\n4\n\n\n1\n2\n4\n3\n\n\n2\n7.5\n7\n2\n\n\n3\n15.5\n9\n1\n\n\n\nThe \\(x_{n+1}\\) and \\(x_n\\) are standard notation to mean the next x (\\(x_{n+1}\\)) and the current x (\\(x_n\\))\nThis process could be extended for as long as you wanted but I hope you can see that you don’t want to do this by hand for very long.\n\n\nEuler’s Method\nMost realistic scenarios involve accelerations that change continuously, not discretely like the examples above. However, we can still employ the method used above if we use a time step (\\(\\Delta t\\)) that is very small. Even if the acceleration varies substantially over long time intervals, it will always be nearly constant over very small time steps. We call this Euler’s method and the steps to implement Euler’s method are as follows:\n\nDefine the initial conditions. For particle motion this involves defining the initial position and velocity of the object as well as any other variable that do not change over time.\nRepeatedly calculate the following quantities.\n\nThe current acceleration. The acceleration function is typically given to you or can be derived from Newton’s law. This expression will always be a function of time,position, and/or velocity and must be re-evaluated every time you advance by a time step.\nUse a kinematic equation to calculate the next position using the previous position and velocity.\nUse a kinematic equation to calculate the next velocity using the previous position and velocity.\nIf you want to store all of your positions and velocities for later use, append them to a list.\n\n\nAn example implementation of Euler’s method for a particle (experiencing no air resistance) thrown upward (with \\(v = 30\\) m/s) from an initial height of \\(y_i = 70\\) m, is shown below.\n\n# Import statements\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nv0 = 30.0 # Initial velocity in m/s\ny0 = 70 # Initial height in m\n\ndelta_t = 0.01 # Time step in seconds (should be small)\nt0 = 0 # Start time in seconds\nt_max = 7.0 #Final Time\n\nN = (t_max - t0)/delta_t # Calculate the number of time steps\n\nN = int(N) # Make sure N is an integer\n# Make lists to store your positions, velocities and times.\ny = [y0]\nv = [v0]\nt = [t0]\n\nfor i in range(N):\n   a = -9.8  # Calculate the current acceleration\n\n   # Store the new position, velocity, and time in the lists\n   v.append(v[i] + a * delta_t)\n   y.append(y[i] + v[i] * delta_t)\n   t.append(t[i] + delta_t)\n\nplt.plot(t,y,linewidth = 2, color = 'red')\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"Position (m)\")\nplt.title(\"Position vs. time for a ball in free fall\")\n\nText(0.5, 1.0, 'Position vs. time for a ball in free fall')\n\n\n\n\n\n\n\nThe code - Broken down\nThis section will break the program down piece by piece. Here’s the first section:\n\n\"\"\"\nOne Dimensional free-fall Euler Code\n\nPH150\nBrother Nelson\n\n\nThis code will calculate the exact solution for a ball in free fall\nhaving been shot straight up using Euler's method.\n\n\"\"\"\n#Import numerical and plotting packages\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nEverything inside the triple quotes (“““) counts as one long comment. If you ever need to add comments that will take more than one line, you can start and end it with \"\"\". It’s a great way to leave yourself notes about what each program does. Below the introductory comment, numpy and matplotlib are imported to do the number crunching and plotting later on.\nThis next part sets up all of the constants and inputs. It’s a good idea to put it at the beginning of the program so that they are easy to change.\n\n#Initial conditions and physical setup constants\nv0=30.0 #Initial velocity in m/s\nx0=70 #Initial Postion in m\n\n#Set up the time steps and number of calculations\ndelta_t = 0.01 #Time step in seconds\nt0=0 #Start time in seconds\nt_max = 7.0 #Final time\n\nThe part with x0 and v0 are the starting position and velocity. delta_t is time step or amount of time that will advance for each calculation. Remember, Euler’s method works by assuming that acceleration is roughly constant over short time intervals. delta_t sets that time interval.\nWith initial values defined, the number of calculations that will be needed can be determined. Here’s the piece of code that does that:\n\n#Calculate the number of timesteps we need to make\nN=(t_max-t0)/delta_t\n#Make sure N is an integer\nN=int(N)\n\nPython keeps two types of numbers: Floats - numbers with decimal points and Integers - whole numbers. For example: \\(2.0\\) is a float, \\(2\\) is an integer. Even though they have the same value, Python sees them as different things. You can only get an item from a list using an integer. (myList[2] works, but myList[2.0] won’t). The command N=int(N) takes whatever number N is and converts it to an integer. The int command truncates instead of rounding, so int(2.9) becomes 2, not 3.\nNext, lists that will eventually store all of the positions, velocities, and times are initialized. Putting square brackets around something tells Python that it is a list. Since more x,v, and t values are going to be added later, we need to warn Python that these are going to be lists. Initially, these lists only contain the initial values.\n\n#Make lists to hold our positions, velocities, and times\nx=[x0]\nv=[v0]\nt=[t0]\n\nThis next section of code is what is called a loop:\n\n#Now perform an Euler's method calculation.\nfor i in range(N):\n    #Find the current acceleration\n    a=-9.8\n    \n   # Store the new position, velocity, and time in the lists\n   v.append(v[i] + a * delta_t)\n   y.append(y[i] + v[i] * delta_t)\n   t.append(t[i] + delta_t)\n\n#End of Euler loop =========================================\n\n\nBreaking down the for loop\nFor most of you, a loop will be a new idea. Loops are very helpful when you need to tell a computer to do something over and over again. Here’s the general structure:\n\nfor &lt;Thing that Changes&gt;:\n     Stuff the computer does to/with the thing that changes\n\nNot part of the loop\n\nThe code that gets inserted at: &lt;Thing that Changes&gt; should be a list of items that are to be iterated over. As an example, consider a famous mathematical sequence of numbers called the Fibonacci sequence. The first few numbers in the Fibonacci sequence are: [1,1,2,3,5,8,13] (Can you see the pattern). A loop to iterate over this list of numbers is shown below:\n\nfibonacci = [1,1,2,3,5,8,13]\nfor num in fibonacci:\n    print(num)\n\n1\n1\n2\n3\n5\n8\n13\n\n\nWhen this code is executed, the sequence of numbers first gets stored in the variable fibonacci. The for num in fibonacci tells Python to look at each thing in the list one by one, and call it num, each in turn. Therefore, this program would first print 1, then 1 (again), then 2, etc. Once all of the numbers have been printed one at a time, the final command will execute and print the entire list. This last statement won’t execute until the loop has successfully iterated over everything in the list named fibonacci.\nNow let’s look at the for statement in the Euler’s code: i in range(N). The range(N) command makes a list of integers from zero to N-1. If N was five, range(N) would be [0,1,2,3,4]. Therefore, the first time through the for loop i=0, the second time i=1, and so on until we reach N-1.\nNow let’s look at the inside of the loop:\n\n    #Find the current acceleration\n    a=-9.8\n    \n   # Store the new position, velocity, and time in the lists\n   v.append(v[i] + a * delta_t)\n   y.append(y[i] + v[i] * delta_t)\n   t.append(t[i] + delta_t)\n\nThis is where Euler’s method is found. First the acceleration is calculated, which is a constant -9.8 in this case but usually will be a function of time, position, and/or velocity. The next statement involves an append statement:\n\n   v.append(v[i] + a * delta_t)\n\nThe append statement is used to add something to the end of a list. In this case, the statement v.append(v[i]+a*delta_t) adds v[i]+a*delta_t to the end of the list named v. This is nothing more than the kinematic equation \\(v_f=v_i+a\\Delta t\\), using v[i] as \\(v_i\\) to calculate the “final” velocity. Each time the computer goes through the loop, a different value for i is used, and therefore a different value for v[i]. If the list starts with just one value in it (v=[0]), then by the end of the first iteration there are two things in the list. (The same can be said for the position and time lists)\nThe first few iterations of this loop are done by hand and placed in the table below to help you see exactly what the loop is doing.\n\n\n\n\n\n\n\n\n\ntime\n$$y_f = y_i + v_i \\Delta t$$\n$$v_f = v_i + a \\Delta t$$\n\n\n\n\n0\n0.0\n70.000\n30.00\n\n\n1\n0.1\n73.000\n29.02\n\n\n2\n0.2\n75.902\n28.04\n\n\n3\n0.3\n78.706\n27.06\n\n\n\n\n\n\n\nVelocity can be used to calculate the position using the kinematic equation \\(x_f=x_i+v_i\\Delta t+\\frac{1}{2}a\\Delta t^2\\). The term \\(\\frac{1}{2}a\\Delta t^2\\) is neglected because if \\(\\Delta t\\) is small then \\(\\Delta t^2\\) will be very small, making this entire term inconsequential. Once the loop is finished, the program just builds a plot of the data:\n\n#Plot the results\nplt.plot(t,x,linewidth=2,color='red')\nplt.xlabel('time (s)')\nplt.ylabel('Position (m)')\nplt.title('Position vs. time for a ball in free fall')\n\n\n\n\nAir Drag\nThis week we will be using Euler’s method to predict the fall time for an object experiencing a non-negligible amount of drag. The drag force acting on a falling object is given by:\n\\[F_D =  {1\\over 2} \\; C \\rho A v^2 \\;\\;\\;\\;\\;(1) \\]\nwhere \\(C\\) is the drag coefficeint and has the following values: 0.5 for a sphere and 0.3 for a cone.\n\\(\\rho\\) is the air density and has a value of 1.02 kg/m\\(^3\\) in Rexburg\nA is the cross-sectional area\nv is the velocity of the object\n\n\n\nApplying Newton’s second law to the free-body diagram shown above gives:\n\\[ \\Sigma F_{y} = -mg + F_{D} = ma_{y} \\;\\;\\;\\;\\;(2) \\]\nSolving for the acceleration in the y-direction gives:\n\\[ a_y = {d v_y \\over dt} = \\frac{ C \\rho A v^{2}}{2m} - g \\;\\;\\;\\;\\;(3)\\]\nNotice that this expression for the acceleration is not constant; it changes as \\(v\\) changes. The kinematic equations can be used to update the position and velocity \\[ y_{n+1} = y_{n} + v_{n} \\cdot \\Delta t \\;\\;\\;\\;\\;(5)\\]\n\\[ v_{n+1} = v_{n} + a_{n} \\cdot \\Delta t \\;\\;\\;\\;\\;(6)\\]\n\\[ = v_{n} + ({C \\rho A v^2 \\over 2 m} - g) \\cdot \\Delta t \\;\\;\\;\\;\\;(6)\\]"
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#python-skills",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#python-skills",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Python skills",
    "text": "Python skills\nIn this lab you will need to use programming loops to use Euler’s method. Loops allow programs to rerun the same block of code multiple times. This might seem like a funny thing to want to do but it turns out that there are many important tasks that are repetitive in nature (perhaps with small changes for each successive repetition). A loop provides a succinct and efficient way to perform tasks of this nature.\n\nFor loop\nThe for loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over. Here is an example of a for loop that is used to add up the elements of a list.\n\nthesum = 0\nfor i in [3,2,1,9.9]: \n    thesum += i\n\nThis would be equivalent to the following code:\n\nthesum = 0\n\nthesum = thesum + 3\nthesum = thesum + 2\nthesum = thesum + 1\nthesum = thesum + 9.9\n\nwhich isn’t that much longer than using a loop. However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long.\nThe correct language is to say that we are iterating over the list [3,2,1,9.9]. This means that the loop variable (i in this case but you can choose it to be whatever you want) gets assigned the values of the list elements, one by one, until it reaches the end of the list. You can use for loops to iterate over any multi-element object like lists or tuples. Python uses indentation to indicate where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.\nOften you will want to iterate over a list of integers. The range function is a good choice for this. The range function takes up to 3 arguments. The first is the starting number, the second is the ending number, and the third is the step size.\nrange(start,stop,stepsize)\n\nfor i in range(5,50,3):  #Generates a list from 5 -&gt; 50 with a step size of 3\n    print(i)\n\n5\n8\n11\n14\n17\n20\n23\n26\n29\n32\n35\n38\n41\n44\n47\n\n\nThese examples are so simple that you might wonder when a loop might actually be useful to you. Let’s see if we can build a loop to calculate the following sum\n\\[ \\sum_{n=1}^{1000} {1\\over n^2} \\tag{1}\\]\n\ntheSum = 0\nfor n in range(1,1000):\n    theSum = theSum + 1/n**2\nprint(theSum)\n\n1.6439335666815615\n\n\nHere, n is being assigned the values 1,2,3,4....1000, one by one, until it gets all the way to 1000. Each time through the loop, n is different and the expression 1/n**2 evaluates to a new value. The variable theSum is updated each time through to be the running total of all calculations performed thus far. Here’s another example of a loop used to calculate the value of \\(20!\\):\n\ntheProduct = 1\nfor n in range(1,21):\n    theProduct = theProduct * n #Multiply theProduct by n\nprint(theProduct)\n\n2432902008176640000\n\n\nRemember that the range function creates a list starting at \\(1\\), going up to \\(21\\) but not including it. The math library has a function called factorial that does the same thing. Let’s use it to check our answer:\n\nfrom math import factorial\nfactorial(20)\n\n2432902008176640000\n\n\n\n\nBoolean logic inside loops\nOften when using loops, we only want a block of code to execute when some condition is satisfied. We can use boolean logic inside of the loop to accomplish this. For example, let’s write a loop to compute the following sum:\n\\[ \\sum_{{n\\over 5} \\in \\text{ Int and } {n\\over 3} \\in \\text{ Int}} {1\\over n^2} \\]\nwhich is similar to the one we did above, but this time we only want to include terms where \\(n\\) is a perfect multiple of both 5 and 3. To check to see if n is a perfect multiple of a number we can calculate the modulo (remainder after division) using the % operator and check that it is equal to zero.\n\ntheSum = 0\nfor n in range(1,1000):\n    if n % 5 == 0 and n % 3 == 0:\n        theSum = theSum + 1/n**2\nprint(theSum)\n\n0.007243985583159138"
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-i-minimum-fall-time",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-i-minimum-fall-time",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Activity I: Minimum Fall Time",
    "text": "Activity I: Minimum Fall Time\n\nGoal (Overview)\nUsing kinematics, calculate the time it takes for a particle to fall, starting from rest, through a distance of \\(6\\) meters, neglecting air drag. This number will serve as a point of comparison when we include air drag in our analysis.\n\n\nProcedure\n\nThe kinematic equations are given below. \\[y_f = y_i + v_i \\Delta t + {1\\over 2}a \\Delta t^2\\] \\[v_f = v_i + a \\Delta t\\] \\[v_f^2 = v_i^2 + 2 a \\Delta x\\] Use these equations to calculate the time it takes for a particle to fall through a distance of \\(6.0\\) meters starting from rest. Neglect air resistance. Show your math and calculations below.\n\n\nInclude kinematic details here\n\n\n# Code to perform calculations here"
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-ii-modeling-the-motion-using-eulers-method",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-ii-modeling-the-motion-using-eulers-method",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Activity II: Modeling the motion using Euler’s method",
    "text": "Activity II: Modeling the motion using Euler’s method\n\nGoal (Overview)\nWrite some python code that will accurately predict the fall time for a projectile that is experiencing air resistance.\n\n\nProcedure\n\nIn the example discussed above, a model for a particle that is thrown upward and experiences no air resistance was constructed. Use equations 3-6 from the “Air Drag” section to modify that code to include air resistance. Set \\(\\rho = 1.02\\) kg/m\\(^3\\), \\(C = 0.5\\) and make reasonable guesses for the values of \\(A\\) and \\(m\\). We’ll fine tune these values later.\nModify the code to model a particle that is dropped from rest rather than thrown upward initially.\nYour value for \\(\\Delta t\\) will need to be reasonably small to get accurate results. Decrease your value of \\(\\Delta t\\) until the results stop changing.\nTo find the flight time, you should use trial and error on t_max until the particle hits the ground.\nAs a test of the correctness of your code, increase the initial height of the projectile and verify that the drop time changes as you would expect.\nAs a test of the correctness of your code, increase the mass of the projectile and verify that the drop time changes as you would expect.\nAs a test of the correctness of your code, decrease the drag constant of the projectile and verify that the drop time changes as you would expect.\n\n\n# Import from libraries\nfrom numpy import pi\n\n\n# Define constants\n\n# Set initial conditions\n\n# Loop to calculate flight time using Euler's method\nwhile # Put your stopping condition here:\n    \n\nplt.ylim(0,y0)"
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-iii-predicting-times",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-iii-predicting-times",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Activity III: Predicting times",
    "text": "Activity III: Predicting times\n\nProcedure\n\nMake mass and diameter measurements on each of the objects given to you.\nChoose a location to perform the drop and measure the initial height. You should find a location that provides a large drop distance. (The track above the I-center or the foyer in the Manwaring center are good choices. We’ve dropped them from the top of the stadium before but a tall fence was recently installed which makes it hard to drop from there. )\nThen use the code you wrote above to predict the drop times for each of the six objects.\nFill in the table below with your predictions.\n\n\n\n\nObject\nMass (kg)\nDiameter (m)\nPrecited fall time (s)\n\n\n\n\nPing Pong Ball\n\n\n\n\n\nStyrofoam cone\n\n\n\n\n\nStyrofoam sphere (small)\n\n\n\n\n\nStyrofoam sphere (medium)\n\n\n\n\n\nBeach ball"
  },
  {
    "objectID": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-iv-comparison-of-predicted-and-measured-times",
    "href": "labs/Lab8-One-Dimensional-Eulers/L8-One-Dimensional-Eulers.html#activity-iv-comparison-of-predicted-and-measured-times",
    "title": "Lab 8 Euler’s Method: Including Air Resistance",
    "section": "Activity IV: Comparison of Predicted and Measured Times",
    "text": "Activity IV: Comparison of Predicted and Measured Times\n\nMeasure the flight time for each object \\(10\\) times.\nCalculate the average fall time for each object.\nCalculate the percent error for each object.\nFill in your results in the table below.\n\n\\[ \\text{% diff} = {\\text{measured} - \\text{predicted} \\over \\text{measured} } \\times 100 \\text{%}\\]\n\n\n\n\n\n\n\n\n\nObject\nPrecited fall time (s)\nAverage measured fall Time (s)\n% Error\n\n\n\n\nPing Pong Ball\n\n\n\n\n\nStyrofoam cone\n\n\n\n\n\nStyrofoam sphere (small)\n\n\n\n\n\nStyrofoam sphere (medium)\n\n\n\n\n\nBeach ball\n\n\n\n\n\n\nYour score on the lab will be based on your % error for the five different objects.\nIf any of your % differences are greater than 10%, give a possible explanation for the discrepancy. &gt; Response:\n\n# Python code here"
  },
  {
    "objectID": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#skills",
    "href": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#skills",
    "title": "Lab 9 Euler’s Method with Uncertainty: Weather Balloons",
    "section": "Skills",
    "text": "Skills\nIn this lab you will gain the following skills\n\nLearn how to construct a Python while loop.\nLearn how to generate random numbers from a statistical distribution.\nLearn how to propagate uncertainty in a numerical calculation."
  },
  {
    "objectID": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#background-information",
    "href": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#background-information",
    "title": "Lab 9 Euler’s Method with Uncertainty: Weather Balloons",
    "section": "Background Information",
    "text": "Background Information\n\nWeather Balloons and Buoyant Forces\nLast time we learned that the force of air drag is given by:\n\\[F_D =  {1\\over 2} \\; C \\rho A |v| v \\;\\;\\;\\;\\;(1) \\]\nand used this together with Euler’s method to predict the fall times for several objects. This week we will study the motion of a weather balloon and predict the time it will take for the weather balloon to rise a chosen distance. This means that we will need to add one more force into the analysis: the buoyant force.\nThe balloon has a total of three forces acting on it: gravity, air drag, and a buoyant force from the surrounding air. The downward gravitational force has three contributions: the weight of the balloon itself, the weight of the helium gas inside the balloon, and the weight of the payload attached to the balloon.\nLet’s first discuss the buoyant force. In principles of physics II you’ll learn that the magnitude of the buoyant force is equal the the weight of the displaced fluid, which in this case is just air. The balloon is displacing a volume of air equal to the balloon’s volume.\n\\[\nF_b = m_\\text{air} g = \\rho_\\text{air} V g\n\\]\nWhere \\(\\rho_\\text{air}\\) is the density of the surrounding air and \\(V\\) is the volume of the balloon. Since the balloon is approximately spherical we’ll use the volume of a sphere:\n\\[\nV = {4\\over 3} \\pi r^3 = {1\\over 6} \\pi d^3\n\\]\nThe density of a gas varies with temperature and pressure according to the following formula:\n\\[\n\\rho(P,T) = \\rho_0 {P \\over P_0} {T_0 \\over T}\n\\]\nwhere \\(\\rho_0\\), \\(T_0\\) and \\(P_0\\) are the density, temperature, and pressure at some common point of reference. We’ll use the values corresponding to standard temperature and pressure (STP) given below:\n\\[\nP_0 = 1.0 \\times 10^5 \\text{ Pa}\n\\]\n\\[\nT_0 = 0^\\circ \\text{ C} = 273.15 \\text{ K}\n\\]\n\\[\n\\rho_\\text{air,0} = 1.2754 \\text{ kg/m}^3\n\\]\n\\[\n\\rho_\\text{He,0} = 0.1784 \\text{ kg/m}^3\n\\]\nLet’s write down Newton’s second law, including all of these terms and see if we can arrive at an expression for the acceleration of the balloon.\n\\[\nF_b - F_g - F_D = m a\n\\]\n\\[\n{F_b - F_g - F_D\\over m} =  a\n\\]\nwhere\n\\[\nF_b = \\rho_\\text{air} V_\\text{balloon} g\n\\]\n\\[\n\\begin{align*}\nF_g &= m_\\text{payload} g + m_\\text{He} g + m_\\text{balloon} g\\\\\n&= m_\\text{payload} g + \\rho_\\text{He} V g + m_\\text{balloon} g\n\\end{align*}\n\\]\n\\[\nF_D = {1\\over 2} \\rho_\\text{air} A_\\text{balloon} C |v| v\n\\]\n\\[\n\\rho_\\text{air} = \\rho_\\text{air,0} {P \\over P_0} {T_0 \\over T}\n\\]\n\\[\n\\rho_\\text{He} = \\rho_\\text{He,0} {P \\over P_0} {T_0 \\over T}\n\\]\n\n\nWhile Loops\nLast week we used a for loop with Euler’s method, which was a good first choice because its easy to understand. However a for loop is often a clunky approach because we often don’t know how many iterations need to be performed to achieve the desired result. For example, last week we showed an example of Euler’s method for a particle launched straight upward and allowed to travel up and then come back down and hit the ground. Instead of performing a specified number of iterations of this loop, it would be nice to let the loop continue until the particle hit the ground. We can do this with a while loop which has the following basic structure:\n\nwhile &lt;stopping condition&gt;\n     &lt;Body of loop&gt;\n\nThe &lt;stopping condition&gt; is a statement that determines whether the loop will continue to run or not. If the statement evaluates to True, the loop continues and if it evaluates to False, it will stop. As a simple example let’s use a while loop find the first 20 numbers in the fibonacci sequence:\n\nprevious = 1 # First number in the Fibonacci sequence\ncurrent = 1 # Second number in the Fibonacci sequence\nn = 2\nwhile n &lt; 20:\n    nextN = current + previous #Find the next Fibonacci number\n    previous = current  # The current number becomes the previous\n    current = nextN  # The next number becomes the current\n    n = n + 1        # Keep track of how many numbers we've found\n    print(nextN)\n\nThe stopping condition for this loop is n &lt; 20, where n is counting how many numbers in the sequence have been found so far. This variable starts off with a value of \\(2\\) and increases by \\(1\\) every time that another number is found. Once the value of n reaches \\(20\\), the statement n &lt; 20 produces a False and the loop terminates.\nwhile loops should be used with caution because you can easily write a faulty stopping condition and inadvertently write a loop that runs forever. This happens because your stopping condition was never met. For example, if the statement n = n + 1 were omitted in the code above, n would never change and the stopping condition n &lt; 20 would never evaluate to False and the loop will run forever. To avoid this, you should always get in the habit of building a fail safe into your while loops. To build a fail safe, first define a variable that counts the number of loop iterations. Then add an if statement inside the loop body to check to see if the value of the counter variable becomes too large. A break statement is used in this case to exit the loop. Below is an example of the loop above with faulty termination logic but with a fail safe to prevent it from looping forever.\n\nprevious = 1 # First number in the Fibonacci sequence\ncurrent = 1 # Second number in the Fibonacci sequence\nn = 2\ncounter = 0\nwhile n &lt; 20:\n    nextN = current + previous #Find the next Fibonacci number\n    previous = current  # The current number becomes the previous\n    current = nextN  # The next number becomes the current\n    counter += 1      # Keep track of how many numbers we've found\n    if counter &gt; 1000:\n        print(\"Something went wrong\")\n        break\n    print(nextN)\n\nTo use a while loop in Euler’s method for a projectile that is going to hit the ground, we should use the stopping condition y[-1] &gt; 0 so that the loop terminates once the position of the projectile becomes negative. The example from last week with the modifications to use a while loop is given below. Notice also that since we no long use the loop variable i, we can’t use it to index the position and velocity lists. Instead we use v[-1] and y[-1] to access the last element in each of these lists.\n\n# Import statements\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nv0 = 30.0 # Initial velocity in m/s\ny0 = 70 # Initial height in m\n\ndelta_t = 0.01 # Time step in seconds (should be small)\nt0 = 0 # Start time in seconds\nt_max = 7.0 #Final Time\n\nN = (t_max - t0)/delta_t # Calculate the number of time steps\n\nN = int(N) # Make sure N is an integer\n# Make lists to store your positions, velocities and times.\ny = [y0]\nv = [v0]\nt = [t0]\n\nwhile y[-1] &gt; 0:\n   a = -9.8  # Calculate the current acceleration\n\n   # Store the new position, velocity, and time in the lists\n   v.append(v[-1] + a * delta_t)\n   y.append(y[-1] + v[-1] * delta_t)\n   t.append(t[-1] + delta_t)\n\nplt.plot(t,y,linewidth = 2, color = 'red')\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"Position (m)\")\nplt.title(\"Position vs. time for a ball in free fall\")\n\nText(0.5, 1.0, 'Position vs. time for a ball in free fall')\n\n\n\n\n\n\n\nPropagating Uncertainty - Random numbers\nA centeral theme in this class is that of propagating uncertainty. When performing numerical simulations, the uncertainties in the measured quantities used will propagate through to the final result. As a simple example, recall the equation for the acceleration due to gravity (\\(g\\)) in terms of the lengthe of a pendulum (\\(L\\)) and its period (\\(T\\)): \\(g = {4 \\pi^2 L \\over T^2}\\). Imagine collecting (L,T) data pairs and wanting to use them to determine the uncertainty on the value of \\(g\\). This situation is depicted graphically in the figures below.\n\n\nText(0.5, 0, 'g (m/s$^2$)')\n\n\n\n\n\nThe top figures represent the distribution of the (L,T) pairs and the one-dimensional projections. The second figure shows the same data as the top figure but now the value of g for each (L,T) data pair is represented by the color of the plot point. Finally the final figure gives the histogram of g values. The standard deviation of this final data set could be used as the uncertainty on \\(g\\). So to propagate uncertainty in a numerical calculation we should run Euler’s method many times, each time starting with a different set of initial conditions. When selecting a value for the initial condition we should generate a random number from the appropriate distribution. This can be accomplished by placing your Euler’s loop from last week into another loop, called the outer loop.\nTo generate a random number from a normal distribution in Python, use the norm.rvs function (short for random variate sample) from the scipy.stats module. (Example below)\n\nimport scipy.stats as sp\n\nrandomNumber = sp.norm.rvs(loc = 5,scale = 0.5)\nprint(randomNumber)\n\n5.160102361887256\n\n\nThe loc keyword argument specifies the mean of the distribution (\\(\\mu\\)) and the scale keyword argument specifies the standard deviation of the distribution (\\(\\sigma\\))."
  },
  {
    "objectID": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-i-modeling-the-balloons-motion-eulers-method",
    "href": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-i-modeling-the-balloons-motion-eulers-method",
    "title": "Lab 9 Euler’s Method with Uncertainty: Weather Balloons",
    "section": "Activity I: Modeling the balloon’s motion (Euler’s Method)",
    "text": "Activity I: Modeling the balloon’s motion (Euler’s Method)\n\nGoal (Overview)\nModify your code from last week to incorporate the buoyant force experienced by the weather balloon.\n\n\nProcedure\n\nMeasure the mass of the balloon before we fill it with helium. Record a value and an uncertainty.\nWe’ll be adding a small payload to the balloon and adjusting it until the time of flight falls in a reasonable range. For now, set the mass of the payload to be \\(m_p = 15\\) grams. We’ll modify this number later.\nMeasure the temperature in the room and assign an uncertainty to this measurement. Convert this temperature to Kelvins using the equation below. Then record this number in the code cell provided below. \\[ T_K = {5 \\over 9}(T_F - 32) + 273.15\\]\nVisit a weather website to look up the atmospheric pressure here in Rexburg. You’ll probably see a number with units of “inHg”, which means “inches of Mercury”. To convert this pressure into Pascals, use the equation below. (The \\(4.865\\) is to undo the sea-level correction and the \\(3386.39\\) is to convert from “inHg” to Pascals.) Record this value in the code cell provided below. \\[ P_\\text{Pa} = 3386.39 \\times (P_\\text{inHg} - 4.865) \\]\nEnter values for \\(T_0\\) \\(P_0\\) in the code cell below using the values shown above.\nEnter the expression for density given above into the code cell provided below for the density of air and helium.\nEnter the expression for \\(V\\) and \\(A\\) in the code cell below in terms of \\(d\\) (diameter).\nEnter the expression for \\(F_b\\) (the buoyant force) in the code cell below using the equation provided above.\nEnter the expression for \\(F_g\\) (the weights) in the code cell below using the equation provided above.\nEnter the expression for \\(F_D\\) (the drag force) in the code cell below using the equation provided above. As a reminder, the equation should be: \\[\n{1\\over 2} \\; C \\rho A |v| v\n\\]\nEnter the expression for \\(a\\) (the acceleration) in the code cell below using the equation provided above. Note that since the acceleration is not constant the calculation must be performed inside the main Euler’s loop.\nFollowing the same pattern from last week, add expressions to update the velocity, position, and time inside the main Euler’s loop.\nCheck with your neighbor and/or B. Nelson to ensure you have done these steps correctly before moving on.\nHave B. Nelson fill your balloon with helium. Once it is filled, devise a method for determining the diameter of the balloon. Record the value and its uncertainty in the code cell below. (Note: The helium will slowly diffuse out of the balloon, so you won’t want much time to pass between when you fill your balloon and when you test your prediction)\nRun your code and verify that your results are reasonable.\nUsing trial and error, adjust the mass of the payload until the time of flight is in the \\(6-10\\) seconds range.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nmb =    # Mass of the balloon (kg).\nmp =    # Mass of the payload (kg).\nT =     # Current temperature (Kelvins).\nP =     # Current pressure (Pa).\n\nρa0 =   # Reference density of air (kg/m^3)\nρh0 =   # Reference density of helium (kg/m^3)\n\nT0 =    # Reference temperature (Kelvins).\nP0 =    # Reference Pressure (Pa).\n\nρa =    # Density of air (kg/m^3)\nρh =   # Density of Helium (kg/m^3)\n\nd =    # Diameter of weather balloon (m).\nV =     # Volume of balloon (m^3).\nA =       # Cross-sectional area of balloon (m^3)\nC = 0.5   # Drag constant for sphere (unitless)\nFb =   # Buoyant Force (N).\n\ng = 9.8  # Acceleration due to gravity (m/s^2)\nmt = mp + mb + ρh * V   # Total mass (kg).\nFg =   # Weight of helium + payload + balloon (N).\n\ndt = 0.01    # Time step (s).\n\ny = []     # Initial height of balloon (meters).\nv = [0]    # Initial speed of balloon (m/s).\na = [ (Fb - Fg)/mt]  #Initial acceleration of the balloon\nt = [0]\nyCeiling =   # Height of the ceiling (meters)\n\nfig = plt.figure(figsize = (8,8))\nax1 = fig.add_subplot(3,1,1)\nax2 = fig.add_subplot(3,1,2)\nax3 = fig.add_subplot(3,1,3)\nif Fb &lt; Fg:\n    print(\"Your balloon will not fly!\")\n    exit()\nwhile y[-1] &lt; yCeiling and t[-1] &lt; 10:\n    Fd =     # Drag Force (N).\n    a.append()      # acceleration (m/s^2).\n    v.append()      # Update velocity\n    y.append()      # Update position\n    t.append()      # Update time.\nax1.plot(t,a,'r.')\nax2.plot(t,v,'g.')\nax3.plot(t,y,'b.')\n    \nplt.show()"
  },
  {
    "objectID": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-ii-including-uncertainty",
    "href": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-ii-including-uncertainty",
    "title": "Lab 9 Euler’s Method with Uncertainty: Weather Balloons",
    "section": "Activity II: Including Uncertainty",
    "text": "Activity II: Including Uncertainty\n\nGoal (Overview)\nUsing the uncertainties that you assigned to your measured values from Activity I, use Euler’s method to calculate the uncertainty in the flight time.\n\n\nProcedure\nTo incorporate uncertainty into Euler’s method, you must repeat your Euler’s loop many times using different values for those quantities that carry uncertainty. In the code cell below you will find a template for doing this. Follow the instructions below to complete the task.\n\nYou’ll notice that the variable names in the code cell have been modified from what they were in Activity I. Instead of “mb” for mass of the balloon, we now have “meanmb” for mean mass of the balloon and “dmb” for uncertainty (or standard deviation) in the mass of the balloon. Transfer all of your measurements and uncertainties from Activity I into the code cell below.\nIf you haven’t yet, record the uncertainties in all of your measured values in the code cell below.\nYou’ll notice that our Euler’s loop from Activity I is now enclosed in a for loop . This will allow us to repeat the Euler’s loop as many times as we would like. We call the Euler’s loop the “inner” loop and the ‘for’ loop the “outer” loop. The first five lines in the outer loop are to select a random number for each of the variables that carry uncertainty. I’ve given an example of how to do this on the first line for the balloon mass. Repeat this same process to select random numbers for the other five quantities that carry uncertainty.\nFill in the correct expressions for the remainder of the code lines that are incomplete. (Most of these lines will be identical to what they were in Activity I.)\nCheck with a neighbor or B. Nelson to verify that you did it correctly.\nRun your code and observe the results. Notice the spread in travel times depicted on the position vs. time graph. (Cool eh!)\nBy modifying the uncertainties in your input variables, determine which variable affects the uncertainty in your travel time the most.\n\n\nimport numpy as np\nimport scipy.stats as sp\nimport matplotlib.pyplot as plt\n\n# Variables with uncertainties attached.\nmeanmb =    # Mass of the balloon (kg).\ndmb =    # Unceratainty in balloon mass (kg).\n\nmeanT =     # Current temperature (Kelvins).\ndT =          # Uncertainty in current temperature (Kelvins).\n\nmeanP =     # Current pressure (Pa).\ndP =          # Uncertainty in current atmospheric pressure (Pa).\n\nmeand =    # Diameter of weather balloon (m).\ndd =           # Uncertainty in diameter of balloon (m).\n\nmeanyCeiling =    # Height of the ceiling (meters)\ndyCeiling = \n\n\n# Variables with no uncertainty attached\n\nmp =          # Mass of the payload (kg)\nρa0 = 1.2754  # Reference density of air (kg/m^3)\nρh0 = 0.1784  # Reference density of helium (kg/m^3)\n\nT0 = 273.15   # Reference temperature (Kelvins).\nP0 = 1.0e5   # Reference Pressure (Pa).\n\nC = 0.5   # Drag constant for sphere (unitless)\ng = 9.8  # Acceleration due to gravity (m/s^2)\ndt = 0.01    # Time step (s).\n\n\nfig = plt.figure(figsize = (8,8))\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\n\ntimes = []\n\nNtrials = 10\nfor N in range(Ntrials):\n    mb = sp.norm.rvs(loc = meanmb, scale = dmb)  # Get a randon number for the balloon mass.\n    d =   # Get a random number for the balloon diameter (m).\n    P =   # Get a random number for the pressure (Pa).\n    T =   # Get a random number for the temperature (Kelvins).\n    yCeiling =   # Get a random number for the ceiling height (m).\n\n    V =     # Volume of balloon (m^3).\n    A =       # Cross-sectional area of balloon (m^3)\n\n    ρa =    # Density of air (kg/m^3)\n    ρh =   # Density of Helium (kg/m^3)\n    mt = mb + mp + ρh * V\n    Fb =   # Buoyant Force (N).\n    Fg =   # Weight of helium + payload + balloon (N).\n    \n    y = [d]     # Initial height of balloon (meters).\n    v = [0]     # Initial velocity of balloon (m/s).\n    a = [(Fb - Fg)/mt]\n    t = [0]     # Initial time (s).\n    \n    if Fb &lt; Fg:  # If the buoyant force isn't enough to lift the balloon, don't run Euler's method.\n        print(\"Your buoyant force is smaller than the weight of the balloon, skipping to next iteration.\")\n        continue\n    while y[-1] &lt; yCeiling:\n        Fd = \n        a.append()  \n        v.append() \n        y.append() \n        t.append()\n    ax1.plot(t,a,'r.')\n    ax2.plot(t,v,'g.')\n    ax3.plot(t,y,'b.')\n    times.append(t[-1])\nax4.histogram(times,bins = 50)\nprint(np.mean(times), np.std(times))\nplt.show()"
  },
  {
    "objectID": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-iii-checking-our-prediction",
    "href": "labs/Lab9-One-D-Eulers-Uncertainty/L9-One-D-Eulers-Uncertainty.html#activity-iii-checking-our-prediction",
    "title": "Lab 9 Euler’s Method with Uncertainty: Weather Balloons",
    "section": "Activity III: Checking our Prediction",
    "text": "Activity III: Checking our Prediction\n\nGoal (Overview):\nThe balloon will be released and allowed to accelerate upwards towards the ceiling. The flight time will be measured and compared against the predicted flight time from Activity II.\n\n\nProcedure\n\nTransfer the average flight time calculated in Activity II with its associated uncertainty into the table below.\nRelease the balloon from your pre-selected initial height and use a stopwatch to time the flight. Repeat the flight at least 5 times and calculate the average and standard deviation of the mean of your data. Record the mean and standard deviation of the mean in the table below.\nCalculate the percent error and include that number in the table.\nIt’s possible that your percent error is high and the most likely explanation is in the measurement of the balloon diameter. If this is the case, return to your code from activity II and investigate what the balloon diameter would need be to reduce the percent error to \\(&lt; 10\\%\\).\n\n\n\n\n–\nFlight Time (s)\nUncertainty (s)\n\n\n\n\nPredicted\n\n\n\n\nMeasured\n\n\n\n\nPercent Error"
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "",
    "text": "Activity IV Firing the Cannon and Testing the Model\nUse the model from Activity I with the values of initial velocity and drag coefficient from Activities II and III to predict the trajectory of the styrofoam ball. You should get a family of trajectories as shown in the figure below. The instructor will give you an initial height . Using the third setting on the projectile launcher, you will need to predict the height of the projectile when \\(x = {1\\over 2} R\\), where R is the range of the motion. A hoop with a \\(10\\) cm diameter will be placed at the values of x and y that you specify.\nDon’t fire your styrofoam ball until the instructor or teaching assistant is there to observe.\nThe points for this section will be:"
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#skills",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#skills",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Skills",
    "text": "Skills\nIn this lab you will gain the following skills\n\nUnderstand air drag in two dimensions.\nKnow what Euler’s method is and how to implement it."
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#background-information",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#background-information",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Background Information",
    "text": "Background Information\n\nAir Drag in two dimensions\nIn this lab, you will develop a model for the two-dimensional motion of a projectile with air resistance. The model will make use of Euler’s method for the x and y components of the motion. The drag force (due to air resistance) is given by:\n\\[F_{D} =  \\frac{1}{2} \\; C \\rho A v^{2} \\;\\;\\;\\;\\;(1) \\]\nwhere C is the drag coefficient, \\(\\rho\\) is the air density, and A is the cross-sectional area of the ball.\nThe equations of motion are:\n\\[ x_{n+1} = x_{n} + v_{x,n} \\cdot \\Delta t \\;\\;\\;\\;\\;(2)\\]\n\\[ y_{n+1} = y_{n} + v_{y,n} \\cdot \\Delta t \\;\\;\\;\\;\\;(3)\\] \\[ v_n = \\sqrt{v_{x,n}^2 + v_{y,n}^2} \\;\\;\\;\\;\\;(4)\\]\n\\[ v_{x,n+1} = v_{x,n} + a_x \\cdot \\Delta t  \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;(5)\\]\n\\[ v_{y,n+1} = v_{y,n} + a_y\\cdot \\Delta t  \\;\\;\\;\\;\\;\\;\\;(6)\\]\nwith the acceleration components given by \\[a_y = -\\frac{B}{m}\\cdot v_{n} \\cdot v_{y,n} \\cdot \\Delta t - g\\] \\[a_x = -\\frac{B}{m}\\cdot v_{n} \\cdot v_{x,n} \\cdot \\Delta t \\] and where \\[B = {1 \\over 2} C\\cdot \\rho \\cdot A\\]\nand just as we did last week:\n\\[ \\rho = \\rho_0 {P\\over P_0}{T_0\\over T}\\]"
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-i-model-for-2-d-motion-with-air-resistance",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-i-model-for-2-d-motion-with-air-resistance",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Activity I Model for 2-d Motion with Air Resistance",
    "text": "Activity I Model for 2-d Motion with Air Resistance\n\nGoal (Overview)\nUse Euler’s method to model the motion of a projectile experiencing non-negligble air drag. Predict the range of the projectile with its associated uncertainty.\n\n\nProcedure\nUse the code template provided below and any codes that you have authored in previous labs to construct your model. Below are some hints/tips:\n\nWe don’t know exact values for the drag coefficient (\\(C\\)) or the projectile’s exit speed. Make a guess for now and we’ll modify these values later.\nPreviously, we have modeled one-dimensional motion which means we only had to calculate a single component of the position and velocity. To model two-dimensional motion, you’ll have to have two components of the position and velocity.\n\nTo calculate the drag force in two dimensions, you’ll need to calculate the speed (magnitude of the velocity vector) of the projectile as it changes. Since you are tracking the components of your velocity, you can do that with the following code numpy.sqrt(vx**2 + vy**2) or numpy.linalg.norm([vx,vy])\nOnce you have finished the code, run it and observe the family of trajectories that result. Then investigate how the following variables affect the shape of the trajectory and the spread in the trajectories:\n\nThe drag constant (\\(C\\))\nThe initial speed of the particle.\nThe cross-sectional area of the particle.\nThe air temperature.\nThe air pressure.\n\n\n\n# Import libaries\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n\n# Variables with uncertainties attached\n    # Define mean g and its uncertainty\n    # Define mean drag coefficient and its uncertainty(Make a guess for now, you'll investigate a better value in activity II)\n    # Define mean radius of projectile and its uncertainty\n    # Define mean air density and its uncertainty\n    # Define mean mass of projectile and its uncertainty\n    # Define mean initial speed of projectile and its uncertainty\n    # Define mean intial launch angle of projectile (in radians) and its uncertainty\n    # Define mean initial x position of projectile and its uncertainty\n    # Define mean initial y position of projectile and its uncertainty\n\n\n# Variables with no uncertainty attached.\n    # Define dt (smaller is better, but if the value is too small, the computation time will be large.)\n\n#Outer Loop to calculate uncertainty\nfor i in range(Ntrials):\n    # Generate a random initial speed (Make a guess for now, we'll modify this later)\n    # Generate a random initial launch angle (radians!!!)\n    # Generate a random g value.\n    # Generate a random value for the radius of the projectile.\n    # Generate a random value for the density of air.\n    # Generate a random value for the mass of the projectile.\n    # Generate a random initial launch location (one for x and one for y)\n    # Generate a random value for the drag constant\n\n    # Calculate cross-sectional area of projectile.\n\n    # Calculate B = 1/2 rho C A\n\n    # Initial Conditions.  Initialize lists for x, y,vx,vy, and t\n\n\n    # Euler's Loop (inner) to calculate the flight time using Euler's equations \n    while y[-1] &gt; 0:\n        # Calculate speed (equation 4)\n        # Calculate ax \n        # Calculate ay\n        # Update vx\n        # Update vy\n        # update x\n        # updata y\n        # update time\n    # Plot y vs x\n\nplt.show()"
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-ii-determination-of-drag-constant",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-ii-determination-of-drag-constant",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Activity II: Determination of Drag Constant",
    "text": "Activity II: Determination of Drag Constant\nA subteam should find a value (and uncertainty) for the drag coefficient (\\(D\\)). A good way to do this is to use a high-speed camera (the one on your phone will probably do) and film the ball dropping. You should drop the ball from a height that give the ball enough time to reach terminal velocity well before it hits the floor. The drag constant can then be calculated using the following equation:\n\\[D = {2 m g \\over \\rho A v_T^2}\\] Use \\(g = (9.8004 \\pm 0.00001)\\) m/s\\(^2\\) and \\(\\rho = (1.23 \\pm 0.01)\\) kg/m\\(^3\\).\nThe rest of the values in the equation will need to be measured. Use the instructions in Appendix I to import your video into Logger Pro.\n\n# Put calculations here"
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-iii-determination-of-exit-speed",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#activity-iii-determination-of-exit-speed",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Activity III: Determination of Exit Speed",
    "text": "Activity III: Determination of Exit Speed\nTo find the launch speed of the ball with its uncertainty, you’ll need to use a photogate placed at the cannon’s exit point similar to how we measured the speed of the pendulum a few weeks ago. Here are a few tips/steps to follow to be successful.\n\nA photogate shows the time that the laser was blocked,so to turn that into a speed, you’ll need to divide a distance by the time\nTo get the uncertainty in time, make several measurements and find the average and standard deviation of your data.\nIf the laser isn’t perfectly aligned with the center of the ball as it goes through, then the part of the ball that blocks the laser will be shorter than the diameter (i.e. less ball will travel through the laser beam). With a bit of geometry, you can show that \\(d_\\text{beam} =d_\\text{ball}\\sqrt{1 - \\alpha^2}\\) where \\(d_\\text{beam}\\) is the amount of ball that went through the beam, \\(d_\\text{ball}\\) is the actual diameter of the ball, and \\(\\alpha\\) is how far from the center of the ball the beam is (as a ratio of the radius). Here’s an example on how to use this equation: If the diameter of the ball were \\(2\\) cm, and I think that I can confidently keep the laser within \\(0.5\\) cm of the center of the ball (50% of the radius), the smallest diameter that I would expect to pass through the beam would be: \\[ d_\\text{beam} =(2\\text{cm}) \\sqrt{1 - 0.5^2} = (1.73 ~\\text{cm}) \\approx 1.7~ \\text{cm}\\] Since I’d expect my diameter to be somewhere between that number and 2 cm, I’d quote the diameter that passes through the beam to be \\(1.85 \\pm 0.15\\) cm."
  },
  {
    "objectID": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#appendix-i",
    "href": "labs/Lab10-Two-D-Eulers-Uncertainty/L10-Two-D-Eulers-Uncertainty.html#appendix-i",
    "title": "Lab 10 Projectile Motion with Drag and Uncertainty",
    "section": "Appendix I",
    "text": "Appendix I\nLogger Pro Movie Capture\nTips 1. Make sure that there is a meter stick in the field of view when the ball is fired.\nLogger Pro Procedure 1. Use Insert&gt;Movie to input the video clip. 2. Click on “Enable/Disable Video Analysis” which is located in the bottom right hand corner of the video window. 3. Click on “Set Scale.” Then click and drag on the image of the meter stick. 4. “Set Origin” to a position on the ground directly below where the ball is launched. 5. Make sure that the video clip is set to the frame just before the ball starts moving. Click on “Add Point” and then click on the ball. The video will advance one frame at a time."
  }
]